import fs from 'node:fs/promises';
import path from 'node:path';
import ora from 'ora';
import { logger } from '../utils/logger.js';
import { findQueriesFile } from '../utils/find-files.js';
import { loadApiModule } from '../utils/load-api.js';

export interface CreateApiTypesOptions {
  output?: string;
  name?: string;
}

const DEFAULT_TYPE_NAME = 'HypequeryApi';

const ensureDotPrefix = (value: string) => (value.startsWith('.') ? value : `./${value}`);

const removeExtension = (value: string) => value.replace(/\.(tsx|ts|mts|cts|jsx|js|mjs|cjs)$/i, '');

function getDefaultOutputPath(queriesFile: string) {
  const directory = path.dirname(queriesFile);
  return path.join(directory, 'client.ts');
}

function buildImportPath(from: string, to: string) {
  const relative = path.relative(path.dirname(from), to).replace(/\\/g, '/');
  return removeExtension(ensureDotPrefix(relative));
}

function buildClientFile(
  typeName: string,
  queries: string[],
  importPath: string
) {
  const lines: string[] = [];
  lines.push('// @generated by hypequery create-api-types');
  lines.push(`// ${new Date().toISOString()}`);
  lines.push('// Do not edit manually.');
  lines.push('');
  lines.push("import type { InferQueryInput, InferQueryResult } from '@hypequery/serve';");
  lines.push(`import type * as HypequeryModule from '${importPath}';`);
  lines.push('');
  lines.push('type ServeApi = HypequeryModule extends { api: infer T }');
  lines.push('  ? T');
  lines.push('  : HypequeryModule extends { default: infer T }');
  lines.push('    ? T');
  lines.push('    : never;');
  lines.push('');
  lines.push(`export type ${typeName} = {`);

  if (queries.length === 0) {
    lines.push('  // No queries registered yet');
  } else {
    for (const query of queries) {
      lines.push(`  ${query}: {`);
      lines.push(
        `    input: InferQueryInput<ServeApi, '${query}'>;`
      );
      lines.push(
        `    output: InferQueryResult<ServeApi, '${query}'>;`
      );
      lines.push('  };');
    }
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

export async function createApiTypesCommand(
  file?: string,
  options: CreateApiTypesOptions = {}
) {
  const queriesFile = await findQueriesFile(file);

  if (!queriesFile) {
    logger.error('Could not find queries file');
    logger.newline();
    logger.info('Expected one of:');
    logger.indent('• analytics/queries.ts');
    logger.indent('• src/analytics/queries.ts');
    logger.indent('• hypequery.ts');
    logger.newline();
    logger.info("Did you run 'hypequery init'?");
    logger.newline();
    logger.info('Or specify the file explicitly:');
    logger.indent('hypequery create-api-types ./path/to/queries.ts');
    logger.newline();
    process.exit(1);
  }

  const outputPath = path.resolve(
    process.cwd(),
    options.output ?? getDefaultOutputPath(queriesFile)
  );
  const typeName = options.name ?? DEFAULT_TYPE_NAME;

  const spinner = ora('Loading serve API...').start();

  try {
    const api = await loadApiModule(queriesFile);
    spinner.succeed('Loaded serve API');

    const queryKeys = Object.keys(api.queries ?? {}).sort();
    const importPath = buildImportPath(outputPath, queriesFile);
    const fileContents = buildClientFile(typeName, queryKeys, importPath);

    await fs.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.writeFile(outputPath, fileContents, 'utf8');

    const relativeOutput = path.relative(process.cwd(), outputPath);

    logger.newline();
    if (queryKeys.length === 0) {
      logger.warn('Generated client for an empty serve catalog. Add queries to your API file.');
    } else {
      logger.success(`Mapped ${queryKeys.length} ${queryKeys.length === 1 ? 'query' : 'queries'}`);
    }
    logger.success(`Wrote ${relativeOutput}`);
    logger.newline();
    logger.info(`Import the generated type and pass it to createHooks() or your HTTP client.`);
  } catch (error) {
    spinner.fail('Failed to generate client types');
    logger.newline();
    if (error instanceof Error) {
      logger.error(error.message);
    } else {
      logger.error(String(error));
    }
    logger.newline();
    process.exit(1);
  }
}
