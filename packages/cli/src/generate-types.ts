import { ClickHouseConnection, ColumnType } from '../../../packages/clickhouse/src/index.js';
import fs from 'fs/promises';
import path from 'path';
import dotenv from 'dotenv';

// Load environment variables from the current directory
dotenv.config();

interface ColumnInfo {
  name: string;
  type: string;
}

const clickhouseToTsType = (type: string): ColumnType => {
  if (type.startsWith('Array(')) {
    const innerType = type.slice(6, -1);
    return `Array(${clickhouseToTsType(innerType)})` as ColumnType;
  }

  switch (type.toLowerCase()) {
    case 'string':
    case 'fixedstring':
      return 'String';
    case 'int8':
    case 'int16':
    case 'int32':
      return 'Int32';
    case 'int64':
      return 'Int64';
    case 'float32':
    case 'float64':
      return 'Float64';
    case 'datetime':
      return 'DateTime';
    case 'date':
      return 'Date';
    default:
      return 'String';
  }
};

export async function generateTypes(outputPath: string) {
  const client = ClickHouseConnection.getClient();

  // Get all tables
  const tablesQuery = await client.query({
    query: 'SHOW TABLES',
    format: 'JSONEachRow'
  });
  const tables = await tablesQuery.json<{ name: string }[]>();

  let typeDefinitions = `// Generated by @hypequery/cli
import { ColumnType } from '@hypequery/clickhouse';

export interface IntrospectedSchema {`;

  // Get columns for each table
  for (const table of tables) {
    const columnsQuery = await client.query({
      query: `DESCRIBE ${table.name}`,
      format: 'JSONEachRow'
    });
    const columns = await columnsQuery.json<ColumnInfo[]>();

    typeDefinitions += `\n  ${table.name}: {`;
    for (const column of columns) {
      typeDefinitions += `\n    ${column.name}: '${clickhouseToTsType(column.type)}';`;
    }
    typeDefinitions += '\n  };';
  }

  typeDefinitions += '\n}\n';

  // Ensure the output directory exists
  const outputDir = path.dirname(path.resolve(outputPath));
  await fs.mkdir(outputDir, { recursive: true });

  // Write the file
  await fs.writeFile(path.resolve(outputPath), typeDefinitions);
} 