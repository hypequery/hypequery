import fs from 'node:fs/promises';
import path from 'node:path';
import { getClickHouseClient } from '../utils/clickhouse-client.js';

export interface ClickHouseGeneratorOptions {
  outputPath: string;
  includeTables?: string[];
  excludeTables?: string[];
}

interface ClickHouseTable {
  name: string;
}

interface ClickHouseColumn {
  name: string;
  type: string;
}

const DEFAULT_WARNING =
  'Warning: No tables match the filter criteria. Check your include/exclude options.';

const capitalizeFirstLetter = (value: string) => value.charAt(0).toUpperCase() + value.slice(1);

const clickhouseToTsType = (type: string): string => {
  if (type.startsWith('Array(')) {
    const innerType = type.slice(6, -1);
    return `Array<${clickhouseToTsType(innerType)}>`;
  }

  if (type.startsWith('Nullable(')) {
    const innerType = type.slice(9, -1);
    return `${clickhouseToTsType(innerType)} | null`;
  }

  if (type.startsWith('Map(')) {
    const mapContent = type.slice(4, -1);
    const commaIndex = mapContent.lastIndexOf(',');

    if (commaIndex !== -1) {
      const keyType = mapContent.substring(0, commaIndex).trim();
      const valueType = mapContent.substring(commaIndex + 1).trim();

      let keyTsType = 'string';
      if (keyType === 'LowCardinality(String)') {
        keyTsType = 'string';
      } else if (keyType.includes('Int') || keyType.includes('UInt')) {
        keyTsType = 'number';
      }

      let valueTsType = 'unknown';
      if (valueType.startsWith('Array(')) {
        const innerType = valueType.slice(6, -1);
        valueTsType = `Array<${clickhouseToTsType(innerType)}>`;
      } else if (valueType.startsWith('Nullable(')) {
        const innerType = valueType.slice(9, -1);
        valueTsType = `${clickhouseToTsType(innerType)} | null`;
      } else {
        valueTsType = clickhouseToTsType(valueType);
      }

      return `Record<${keyTsType}, ${valueTsType}>`;
    }

    return 'Record<string, unknown>';
  }

  switch (type.toLowerCase()) {
    case 'string':
    case 'fixedstring':
      return 'string';
    case 'int8':
    case 'int16':
    case 'int32':
    case 'uint8':
    case 'int64':
    case 'uint16':
    case 'uint32':
    case 'uint64':
      return 'number';
    case 'uint128':
    case 'uint256':
    case 'int128':
    case 'int256':
      return 'string';
    case 'float32':
    case 'float64':
    case 'decimal':
      return 'number';
    case 'datetime':
    case 'datetime64':
    case 'date':
    case 'date32':
      return 'string';
    case 'bool':
    case 'boolean':
      return 'boolean';
    default:
      return 'string';
  }
};

async function fetchTables(includeTables?: string[], excludeTables?: string[]) {
  const client = getClickHouseClient();
  const tablesQuery = await client.query({
    query: 'SHOW TABLES',
    format: 'JSONEachRow',
  });

  let tables = (await tablesQuery.json()) as ClickHouseTable[];

  if (includeTables?.length) {
    tables = tables.filter(table => includeTables.includes(table.name));
  }

  if (excludeTables?.length) {
    tables = tables.filter(table => !excludeTables.includes(table.name));
  }

  return tables;
}

async function fetchColumns(table: string) {
  const client = getClickHouseClient();
  const columnsQuery = await client.query({
    query: `DESCRIBE TABLE ${table}`,
    format: 'JSONEachRow',
  });

  return (await columnsQuery.json()) as ClickHouseColumn[];
}

export async function generateClickHouseTypes(options: ClickHouseGeneratorOptions) {
  const { outputPath, includeTables, excludeTables } = options;

  const tables = await fetchTables(includeTables, excludeTables);

  if (tables.length === 0) {
    console.warn(DEFAULT_WARNING);
  }

  let typeDefinitions = `// Generated by hypequery\n` +
    `// This file defines TypeScript types based on your ClickHouse database schema\n\n` +
    `export interface IntrospectedSchema {`;

  for (const table of tables) {
    const columns = await fetchColumns(table.name);
    typeDefinitions += `\n  ${table.name}: {`;

    for (const column of columns) {
      const clickHouseType = column.type.replace(/'/g, "\\'");
      typeDefinitions += `\n    '${column.name}': '${clickHouseType}';`;
    }

    typeDefinitions += '\n  };';
  }

  typeDefinitions += '\n}\n';
  typeDefinitions += `\n// Type-safe record types for each table\n`;

  for (const table of tables) {
    const columns = await fetchColumns(table.name);
    typeDefinitions += `export interface ${capitalizeFirstLetter(table.name)}Record {`;

    for (const column of columns) {
      const tsType = clickhouseToTsType(column.type).replace(/'/g, '');
      typeDefinitions += `\n  '${column.name}': ${tsType};`;
    }

    typeDefinitions += '\n}\n\n';
  }

  typeDefinitions += `
/**
 * Usage example:
 *
 * import { createQueryBuilder } from '@hypequery/clickhouse';
 * import { IntrospectedSchema } from './path-to-this-file';
 *
 * const db = createQueryBuilder<IntrospectedSchema>();
 * const results = await db
 *   .table('${tables.length > 0 ? tables[0].name : 'table_name'}')
 *   .select(['column1', 'column2'])
 *   .where('column1', 'eq', 'value')
 *   .execute();
 */
`;

  const outputDir = path.dirname(path.resolve(outputPath));
  await fs.mkdir(outputDir, { recursive: true });
  await fs.writeFile(path.resolve(outputPath), typeDefinitions);
}
