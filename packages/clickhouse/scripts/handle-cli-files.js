#!/usr/bin/env node

/**
 * Script to handle CLI files.
 * This script:
 * 1. Creates the dist/cli directory if it doesn't exist
 * 2. Ensures all required CLI files exist in dist/cli
 * 3. Makes bin.js executable
 * 4. Ensures all required exports are present
 * 5. Performs detailed verification of required files
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const srcDir = path.join(rootDir, 'src');
const srcCliDir = path.join(srcDir, 'cli');
const distDir = path.join(rootDir, 'dist');
const distCliDir = path.join(distDir, 'cli');

console.log('Starting CLI files handling...');
console.log(`Source CLI directory: ${srcCliDir}`);
console.log(`Destination CLI directory: ${distCliDir}`);

// Create dist/cli directory if it doesn't exist
if (!fs.existsSync(distCliDir)) {
  console.log('Creating dist/cli directory...');
  fs.mkdirSync(distCliDir, { recursive: true });
}

// Check if src/cli directory exists
if (!fs.existsSync(srcCliDir)) {
  console.warn(`Warning: Source CLI directory (${srcCliDir}) does not exist! Will create required files directly.`);
}

// Essential CLI files that must exist
const essentialCliFiles = [
  {
    name: 'bin.js',
    content: `#!/usr/bin/env node

import { ClickHouseConnection } from '../core/connection.js';
import { generateTypes } from './generate-types.js';
import path from 'path';
import dotenv from 'dotenv';
import fs from 'fs/promises';

// Load environment variables from the current directory
dotenv.config();

// Main CLI function
async function main() {
  console.log('HypeQuery TypeScript Generator');
  
  // Get output path (default or from args)
  const outputPath = process.argv.length > 2 ? process.argv[2] : './generated-schema.ts';

  try {
    const host = process.env.CLICKHOUSE_HOST || 'http://localhost:8123';
    const database = process.env.CLICKHOUSE_DATABASE || 'default';

    // Initialize connection from env vars
    ClickHouseConnection.initialize({
      host,
      username: process.env.CLICKHOUSE_USER || 'default',
      password: process.env.CLICKHOUSE_PASSWORD || '',
      database,
    });

    // Ensure directory exists
    const dir = path.dirname(path.resolve(outputPath));
    await fs.mkdir(dir, { recursive: true });

    // Generate types
    await generateTypes(outputPath);

    console.log(\`Success! Types generated at \${path.resolve(outputPath)}\`);
  } catch (error) {
    console.error(\`Error generating types: \${error.message}\`);
    process.exit(1);
  }
}

// Execute the main function
main();`
  },
  {
    name: 'generate-types.js',
    content: `import { ClickHouseConnection } from '../core/connection.js';
import fs from 'fs/promises';
import path from 'path';
import dotenv from 'dotenv';

// Load environment variables from the current directory
dotenv.config();

/**
 * Generates TypeScript type definitions from the ClickHouse database schema
 * @param {string} outputPath - The file path where the type definitions will be written
 * @returns {Promise<void>}
 */
export async function generateTypes(outputPath) {
  const client = ClickHouseConnection.getClient();

  // Get all tables
  const tablesQuery = await client.query({
    query: 'SHOW TABLES',
    format: 'JSONEachRow'
  });
  const tables = await tablesQuery.json();

  let typeDefinitions = \`// Generated by @hypequery/clickhouse
import { ColumnType } from '@hypequery/clickhouse';

export interface IntrospectedSchema {\`;

  // Get columns for each table
  for (const table of tables) {
    const columnsQuery = await client.query({
      query: \`DESCRIBE \${table.name}\`,
      format: 'JSONEachRow'
    });
    const columns = await columnsQuery.json();

    typeDefinitions += \`\\n  \${table.name}: {\`;
    for (const column of columns) {
      typeDefinitions += \`\\n    \${column.name}: 'String';\`;
    }
    typeDefinitions += '\\n  };';
  }

  typeDefinitions += '\\n}\\n';

  // Ensure the output directory exists
  const outputDir = path.dirname(path.resolve(outputPath));
  await fs.mkdir(outputDir, { recursive: true });

  // Write the file
  await fs.writeFile(path.resolve(outputPath), typeDefinitions);
}`
  },
  {
    name: 'index.js',
    content: `// CLI module exports
export { generateTypes } from './generate-types.js';`
  }
];

// Check for and copy or create essential CLI files
console.log('\nProcessing essential CLI files:');
for (const file of essentialCliFiles) {
  const srcPath = path.join(srcCliDir, file.name);
  const destPath = path.join(distCliDir, file.name);

  if (fs.existsSync(srcPath)) {
    console.log(`Copying ${file.name} from source...`);
    fs.copyFileSync(srcPath, destPath);
  } else if (!fs.existsSync(destPath)) {
    console.log(`Creating ${file.name} in dist...`);
    fs.writeFileSync(destPath, file.content);
  } else {
    console.log(`File ${file.name} already exists in dist.`);
  }

  // Make bin.js executable
  if (file.name === 'bin.js') {
    try {
      console.log('Making bin.js executable...');
      fs.chmodSync(destPath, '755');
    } catch (error) {
      console.warn(`Could not make bin.js executable: ${error.message}`);
    }
  }
}

// Copy any other JS and declaration files
if (fs.existsSync(srcCliDir)) {
  console.log('\nCopying additional files from source:');
  const cliFiles = fs.readdirSync(srcCliDir);
  for (const file of cliFiles) {
    if ((file.endsWith('.js') || file.endsWith('.d.ts')) &&
      !essentialCliFiles.some(f => f.name === file)) {
      const srcPath = path.join(srcCliDir, file);
      const destPath = path.join(distCliDir, file);

      console.log(`Copying additional file: ${file}`);
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

// Ensure main index.js exists and has the correct exports
const mainIndexPath = path.join(distDir, 'index.js');
let mainIndexContent = '';

if (fs.existsSync(mainIndexPath)) {
  console.log('\nChecking main index.js for CLI exports...');
  mainIndexContent = fs.readFileSync(mainIndexPath, 'utf-8');

  if (mainIndexContent.includes("export { generateTypes } from './cli/generate-types.js'")) {
    console.log('✓ CLI exports found in main index.js');
  } else {
    console.log('Adding CLI exports to main index.js...');

    // Add a newline before adding exports if the file isn't empty
    if (mainIndexContent.length > 0 && !mainIndexContent.endsWith('\n')) {
      mainIndexContent += '\n';
    }

    mainIndexContent += "\n// CLI exports\nexport { generateTypes } from './cli/generate-types.js';\n";
    fs.writeFileSync(mainIndexPath, mainIndexContent);
    console.log('✓ CLI exports added to main index.js');
  }
} else {
  console.warn('Warning: Main index.js does not exist! Creating minimal version...');
  mainIndexContent = `// Minimal index.js created by CLI build script
export { ClickHouseConnection } from './core/connection.js';

// CLI exports
export { generateTypes } from './cli/generate-types.js';
`;
  fs.writeFileSync(mainIndexPath, mainIndexContent);
  console.log('✓ Created minimal main index.js with CLI exports');
}

// Verify required files exist
console.log('\nVerifying required files:');
const requiredFiles = [
  'dist/cli/bin.js',
  'dist/cli/generate-types.js',
  'dist/cli/index.js',
  'dist/index.js'
];

let allFilesExist = true;
for (const file of requiredFiles) {
  const filePath = path.join(rootDir, file);
  if (fs.existsSync(filePath)) {
    console.log(`✓ Found: ${file}`);
  } else {
    console.error(`✗ Missing: ${file}`);
    allFilesExist = false;
  }
}

if (!allFilesExist) {
  console.error('\nSome required files are missing! Build will fail.');
  process.exit(1);
}

// Additional debug: List all files in dist/cli
console.log('\nContents of dist/cli directory:');
try {
  const cliDirContents = fs.readdirSync(distCliDir);
  if (cliDirContents.length === 0) {
    console.log('(empty)');
  } else {
    cliDirContents.forEach(file => {
      console.log(` - ${file}`);
    });
  }
} catch (error) {
  console.error(`Error reading dist/cli directory: ${error.message}`);
}

console.log('\nCLI files handled successfully!'); 