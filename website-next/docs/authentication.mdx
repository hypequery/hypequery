---
title: Authentication
description: Secure hypequery endpoints with auth strategies, middleware, and runtime context
---

import { Callout } from 'fumadocs-ui/components/callout';
import { CodeBlock } from 'fumadocs-ui/components/codeblock';

# Authentication

`@hypequery/serve` keeps authentication explicit: you provide auth strategy functions that accept the incoming request (or embedded call) and return your auth context. This page shows how to register strategies globally, override them per-endpoint, and propagate auth data through middleware or embedded calls.

## Core Concepts

- **Auth strategies** run before middleware/handlers. They receive `{ request, endpoint }` and return an `AuthContext` object or `null`.
- **Global vs per-endpoint** – pass `auth` in `initServe` to enforce auth across every query. Individual queries can override or disable auth.
- **Auth context** is injected into `ctx.auth` and forwarded to tenant helpers, middlewares, and hooks.
- **Failures** – returning `null` triggers an `UNAUTHORIZED` error and fires `onAuthFailure` hooks.

## Basic Usage

<CodeBlock>
```typescript
import { initServe } from '@hypequery/serve';
import { z } from 'zod';
import { db } from './client';

const apiKeyStrategy = async ({ request }) => {
  const key = request.headers['x-api-key'];
  if (!key || key !== process.env.HQ_API_KEY) {
    return null;
  }
  return { userId: 'service:dashboard', roles: ['internal'] };
};

const { define, queries, query } = initServe({
  auth: apiKeyStrategy,
  context: () => ({ db }),
});

export const api = define({
  queries: queries({
    revenue: query
      .describe('Get revenue metrics')
      .input(z.object({ range: z.string() }))
      .query(({ ctx, input }) =>
        ctx.db
          .table('revenue')
          .where('range', 'eq', input.range)
          .select('*')
          .execute()
      ),
  }),
});
```
</CodeBlock>

Every HTTP request must include `x-api-key`; otherwise, the runtime returns `401 UNAUTHORIZED`.

## Multiple Strategies

Need to support API keys and bearer tokens simultaneously? Provide an array:

<CodeBlock>
```typescript
const bearerStrategy = async ({ request }) => {
  const header = request.headers.authorization;
  if (!header?.startsWith('Bearer ')) return null;
  const token = header.slice(7);
  const payload = await verifyJwt(token);
  return { userId: payload.sub, scopes: payload.scopes };
};

const { define, queries } = initServe({
  auth: [apiKeyStrategy, bearerStrategy],
  context: () => ({ db }),
});
```
</CodeBlock>

Strategies run sequentially until one returns an auth context. If all return `null`, the request is rejected.

## Per-Endpoint Overrides

Some endpoints might need different auth rules (or none at all). Use `.auth()` on the query builder:

<CodeBlock>
```typescript
export const api = define({
  queries: queries({
    healthcheck: query
      .describe('Health check endpoint')
      .auth(null) // public endpoint
      .query(async () => ({ ok: true })),

    adminOnly: query
      .describe('Admin-only endpoint')
      .auth(async ({ request }) => {
        const token = request.headers['x-admin-token'];
        return token === process.env.ADMIN_TOKEN
          ? { roles: ['admin'] }
          : null;
      })
      .query(({ ctx }) =>
        ctx.db
          .table('secrets')
          .select('*')
          .execute()
      ),
  }),
});
```
</CodeBlock>

When `.auth(null)` is used, the endpoint bypasses global strategies entirely.

## Accessing Auth in Middleware/Handlers

`ctx.auth` contains whichever object your strategy returned:

<CodeBlock>
```typescript
const logUserMiddleware = async (ctx, next) => {
  console.log('request', ctx.metadata.path, 'user', ctx.auth?.userId ?? 'anonymous');
  return next();
};

const { define } = initServe({
  middlewares: [logUserMiddleware],
  auth: apiKeyStrategy,
  context: () => ({ db }),
});
```
</CodeBlock>

You can enrich the context by returning additional fields from the strategy (roles, tenant IDs, plan tier, etc.).

## Embedded Execution

When calling `api.run` directly (cron jobs, SSR handlers), pass a synthetic request so your strategies still run:

<CodeBlock>
```typescript
await api.run('revenue', {
  input: { range: '30d' },
  request: {
    method: 'POST',
    path: '/revenue',
    headers: { 'x-api-key': process.env.HQ_API_KEY },
    query: {},
  },
});
```
</CodeBlock>

<Callout type="info" title="Bypassing auth for internal calls">
If you already trust the caller (e.g., an internal job), you can skip strategies by providing a custom context:
</Callout>

<CodeBlock>
```typescript
// Direct execution without auth
const result = await api.run('revenue', {
  context: { db: yourDbConnection, auth: { userId: 'system' } },
  input: { range: '30d' },
});
```
</CodeBlock>

## Framework Integration

### Next.js App Router

<CodeBlock>
```typescript
// app/api/analytics/[...path]/route.ts
import { api } from '@/analytics/queries';
import { createFetchHandler } from '@hypequery/serve';

const handler = createFetchHandler(api.handler);

export const runtime = 'nodejs';
export const GET = handler;
export const POST = handler;
```
</CodeBlock>

### Hono

<CodeBlock>
```typescript
// src/app.ts
import { api } from './analytics/queries';
import { createFetchHandler } from '@hypequery/serve';
import { Hono } from 'hono';

const app = new Hono();
const hypequery = createFetchHandler(api.handler);

app.all('/api/*', (c) => hypequery(c.req.raw));
```
</CodeBlock>

## Troubleshooting

### Missing headers

Ensure your framework forwards headers to the hypequery handler. For example, when proxying through Next.js or Vercel, copy `Authorization`/`X-API-Key` into the request.

### Edge runtimes

Use `createFetchHandler` or `createVercelEdgeHandler` so headers/requests stay compatible with the strategies.

### Logging failures

Implement hooks to capture repeated failures and alert your team:

<CodeBlock>
```typescript
const { define } = initServe({
  auth: apiKeyStrategy,
  hooks: {
    onAuthFailure: async ({ request, endpoint }) => {
      // Log to your monitoring system
      console.warn('Auth failed', {
        ip: request.headers['x-forwarded-for'],
        endpoint: endpoint.key,
      });
    },
  },
  context: () => ({ db }),
});
```
</CodeBlock>

With these patterns you can safely protect hypequery endpoints without tying yourself to a specific auth provider. Strategies are just functions—swap tokens, cookies, mTLS metadata, or anything your stack supports.
