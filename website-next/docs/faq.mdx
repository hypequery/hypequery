---
title: FAQ
description: Frequently asked questions about hypequery
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { CodeBlock } from 'fumadocs-ui/components/codeblock';

# Frequently Asked Questions

## General

<Accordions type="single">
  <Accordion title="What is hypequery?">
    hypequery is a code-first analytics layer for ClickHouse. It provides type-safe query building, named query definitions, and optional HTTP/React integration. It's a library, not a hosted platform.
  </Accordion>

  <Accordion title="Is hypequery production-ready?">
    Yes. hypequery is used in production environments. It's designed for teams that need type-safe, reusable analytics queries.
  </Accordion>

  <Accordion title="What databases does hypequery support?">
    Currently ClickHouse only. hypequery is purpose-built for ClickHouse's analytical workloads (OLAP).
  </Accordion>

  <Accordion title="Is hypequery open source?">
    Yes. hypequery is open source and available on GitHub.
  </Accordion>
</Accordions>

## Serve vs Standalone

<Accordions type="single">
  <Accordion title="When should I use serve framework?">
    Use serve when you need to:
    - Reuse the same analytics across multiple contexts (APIs, cron jobs, agents, dashboards)
    - Auto-generate HTTP endpoints with OpenAPI
    - Get built-in input validation with Zod schemas
    - Access authentication and multi-tenancy features

    See [Installation Options](/docs/getting-started/installation-options) for the full comparison.
  </Accordion>

  <Accordion title="When should I use standalone?">
    Use standalone when you:
    - Are integrating into existing API frameworks (Express, Fastify, Next.js routes)
    - Building one-off scripts or background jobs
    - Want maximum control without any framework layer
    - Don't need to reuse queries across contexts

    See [When to Use Standalone](/docs/standalone/when-to-use) for more details.
  </Accordion>

  <Accordion title="Can I switch from standalone to serve later?">
    Yes! The query builder API is identical. Just wrap your queries in `defineServe()`:

    <CodeBlock>
    ```ts
    // Before (standalone)
    const users = await db.table('users')
      .where('status', 'eq', 'active')
      .execute();

    // After (serve - same query builder)
    export const api = define({
      queries: queries({
        activeUsers: query.query(({ ctx }) =>
          ctx.db.table('users')
            .where('status', 'eq', 'active')
            .execute()
        ),
      }),
    });
    ```
    </CodeBlock>
  </Accordion>
</Accordions>

## Usage

<Accordions type="single">
  <Accordion title="Do I need to use .execute() with serve?">
    Yes! Both serve and standalone use `.execute()`:

    <CodeBlock>
    ```ts
    // Serve framework
    query: ({ ctx }) =>
      ctx.db.table('users')
        .where('status', 'eq', 'active')
        .execute() // ✅ Required

    // Standalone
    const users = await db.table('users')
      .where('status', 'eq', 'active')
      .execute(); // ✅ Required
    ```
    </CodeBlock>

    The difference: serve uses `ctx.db` and you return the promise; standalone uses `db` and you await it.
  </Accordion>

  <Accordion title="Can I use raw SQL?">
    Yes, but use it sparingly. hypequery provides a `raw()` method for SQL fragments:

    <CodeBlock>
    ```ts
    db.table('events')
      .raw('WHERE date BETWEEN toStartOfMonth(now()) AND now()')
      .execute();
    ```
    </CodeBlock>

    For full raw SQL queries, use the `rawQuery()` method on the database client.
  </Accordion>

  <Accordion title="How do I handle mutations (INSERT/UPDATE/DELETE)?">
    hypequery is optimized for analytics (OLAP), not transactions (OLTP). For mutations, use `rawQuery()`:

    <CodeBlock>
    ```ts
    await db.rawQuery(`
      INSERT INTO users (id, name, email)
      VALUES (1, 'Alice', 'alice@example.com')
    `);
    ```
    </CodeBlock>

    See the [GitHub discussion](https://github.com/hypequeryio/hypequery/discussions) for the design rationale.
  </Accordion>

  <Accordion title="Does hypequery support ClickHouse materialized views?">
    Yes. Treat materialized views as regular tables in your schema:

    <CodeBlock>
    ```ts
    db.table('user_stats_mv') // Materialized view
      .where('active', 'eq', true)
      .select(['user_id', 'total_orders'])
      .execute();
    ```
    </CodeBlock>
  </Accordion>

  <Accordion title="How do I handle NULL values?">
    Use `isNull` and `isNotNull` operators:

    <CodeBlock>
    ```ts
    db.table('users')
      .where('deleted_at', 'isNull', null)
      .select(['id', 'name'])
    ```
    </CodeBlock>
  </Accordion>
</Accordions>

## React Hooks

<Accordions type="single">
  <Accordion title="Do I need React hooks?">
    No. React hooks (`@hypequery/react`) are optional and only needed if you're building React applications. You can use serve framework without React.
  </Accordion>

  <Accordion title="Can I use React hooks without serve?">
    No. React hooks require the serve framework to work. If you're using standalone, you'll need to create your own HTTP endpoints and use TanStack Query directly.
  </Accordion>

  <Accordion title="Do React hooks work with Next.js?">
    Yes! React hooks work great with Next.js (both Pages Router and App Router). See the [Next.js recipe](/docs/recipes/nextjs) for setup instructions.
  </Accordion>
</Accordions>

## Performance & Caching

<Accordions type="single">
  <Accordion title="Does hypequery support caching?">
    Yes. Both serve and standalone support caching with multiple strategies:
    - `cache-first`: Return cached data when fresh
    - `network-first`: Always fetch, fallback to cache on error
    - `stale-while-revalidate`: Serve stale data while refreshing

    See [Caching](/docs/serve/caching) for details.
  </Accordion>

  <Accordion title="How do I optimize slow queries?">
    1. **Use ClickHouse query settings:**
       <CodeBlock>
       ```ts
       db.table('large_table')
         .settings({ max_threads: 8 })
         .execute();
       ```
       </CodeBlock>

    2. **Add appropriate WHERE clauses** to reduce data scanned

    3. **Use streaming** for large result sets:
       <CodeBlock>
       ```ts
       await db.table('events').streamForEach((rows) => {
         // Process in batches
       });
       ```
       </CodeBlock>

    4. **Check ClickHouse indexes** on filtered columns

    5. **Use materialized views** for common aggregations
  </Accordion>

  <Accordion title="Can I stream large result sets?">
    Yes. Use `stream()` or `streamForEach()`:

    <CodeBlock>
    ```ts
    const stream = await db.table('events').stream();
    // Or
    await db.table('events').streamForEach((rows) => {
      console.log(rows);
    });
    ```
    </CodeBlock>
  </Accordion>
</Accordions>

## Deployment

<Accordions type="single">
  <Accordion title="Where can I deploy hypequery?">
    hypequery runs anywhere Node.js runs:
    - Vercel, Netlify, AWS Lambda (serverless)
    - Docker containers
    - Traditional Node.js servers
    - Edge runtimes (Cloudflare Workers with compatible ClickHouse client)

    See [Embedded Runtime](/docs/deploy/embedded-runtime) for deployment patterns.
  </Accordion>

  <Accordion title="Do I need to run the hypequery dev server in production?">
    No. The `hypequery dev` command is for local development only. In production:
    - Use `api.run()` for in-process execution
    - Use `serveHTTP()` to expose via your existing web server

    See [HTTP + OpenAPI](/docs/deploy/http-openapi) for production setup.
  </Accordion>

  <Accordion title="How do I handle authentication?">
    Use serve framework middleware:

    <CodeBlock>
    ```ts
    const { define } = initServe({
      context: async ({ req }) => {
        const user = await authenticateRequest(req);
        return { db, user };
      },
    });
    ```
    </CodeBlock>

    See [Authentication](/docs/serve/authentication) for patterns.
  </Accordion>
</Accordions>

## Troubleshooting

<Accordions type="single">
  <Accordion title="TypeScript errors with schema types">
    Ensure you've generated types from your ClickHouse schema:

    <CodeBlock>
    ```bash
    npx hypequery generate
    ```
    </CodeBlock>

    This creates `schema.ts` with types matching your database.
  </Accordion>

  <Accordion title='"Module not found" errors'>
    Check peer dependencies are installed:

    <CodeBlock>
    ```bash
    npm install @hypequery/clickhouse @hypequery/serve zod
    npm install @hypequery/react @tanstack/react-query  # If using React
    ```
    </CodeBlock>
  </Accordion>

  <Accordion title="Query returns empty results">
    Common causes:
    1. **WHERE conditions too restrictive** - Check your filters
    2. **Wrong table name** - Verify table exists in schema
    3. **ClickHouse permissions** - Ensure user can read the table
    4. **No data** - Verify table has data matching your conditions

    Use `debug()` to inspect the generated SQL:

    <CodeBlock>
    ```ts
    db.table('users')
      .where('status', 'eq', 'active')
      .debug() // Logs SQL
      .execute();
    ```
    </CodeBlock>
  </Accordion>

  <Accordion title="Connection timeout errors">
    Increase timeout in connection config:

    <CodeBlock>
    ```ts
    const db = createQueryBuilder<Schema>({
      url: process.env.CLICKHOUSE_URL,
      request_timeout: 60000, // 60 seconds
    });
    ```
    </CodeBlock>
  </Accordion>
</Accordions>

## Migration & Integration

<Accordions type="single">
  <Accordion title="Can I use hypequery with Prisma?">
    Yes, but they serve different purposes:
    - Use Prisma for transactional data (OLTP)
    - Use hypequery for analytics (OLAP)

    Both can coexist in the same application.
  </Accordion>

  <Accordion title="Can I use hypequery with existing ClickHouse tables?">
    Yes! Generate types from your existing schema:

    <CodeBlock>
    ```bash
    npx hypequery generate
    ```
    </CodeBlock>

    Then use the query builder with your tables.
  </Accordion>

  <Accordion title="How do I migrate from raw SQL queries?">
    Convert incrementally:

    <CodeBlock>
    ```ts
    // Before: Raw SQL
    const results = await clickhouse.query(`
      SELECT country, SUM(amount) as revenue
      FROM orders
      WHERE status = 'completed'
      GROUP BY country
      ORDER BY revenue DESC
      LIMIT 10
    `);

    // After: hypequery
    const results = await db
      .table('orders')
      .where('status', 'eq', 'completed')
      .select(['country'])
      .sum('amount', 'revenue')
      .groupBy(['country'])
      .orderBy('revenue', 'DESC')
      .limit(10)
      .execute();
    ```
    </CodeBlock>

    Benefits: Type safety, reusability, validation.
  </Accordion>
</Accordions>

---

## Still have questions?

Check the [GitHub Discussions](https://github.com/hypequeryio/hypequery/discussions) or open an issue.
