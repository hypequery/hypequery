---
title: HTTP + OpenAPI
description: Expose hypequery metrics through HTTP handlers and autogenerated docs
---

import { CodeBlock } from 'fumadocs-ui/components/codeblock';
import { Pre } from 'fumadocs-ui/components/codeblock';

# HTTP + OpenAPI Delivery

hypequery can expose your queries as HTTP endpoints with automatically generated OpenAPI documentation.

## Quick Example

Here's a complete example of exposing a query via HTTP:

**1. Define your query:**

<CodeBlock>
<Pre>
```typescript
// src/analytics/queries.ts
import { initServe } from '@hypequery/serve';
import { z } from 'zod';
import { db } from './client';

const { define, queries, query } = initServe({
  context: () => ({ db }),
});

export const api = define({
  queries: queries({
    revenue: query
      .describe('Get total revenue')
      .output(z.object({
        total: z.number(),
        count: z.number(),
      }))
      .query(async ({ ctx }) => {
        const rows = await ctx.db
          .table('orders')
          .sum('amount', 'total')
          .count('order_id', 'count')
          .execute();

        return rows[0];
      }),
  }),
});

// âœ… Register the route - required for HTTP access!
api.route('/revenue', api.queries.revenue, { method: 'POST' });
```
</Pre>
</CodeBlock>

**2. Start the server:**

<CodeBlock>
<Pre>
```bash
npx hypequery dev src/analytics/queries.ts
# Server running at http://localhost:4000
```
</Pre>
</CodeBlock>

> `hypequery dev` spins up the same HTTP server your `api.handler` uses, so once you register routes (step 1) every endpoint is reachable without any extra wiring. In production you can do the equivalent by calling `await api.start({ port })`, or by embedding `api.handler` inside your own framework/server if you don't want to rely on the CLI entry point.

**3. Call your API:**

<CodeBlock>
<Pre>
```bash
curl -X POST http://localhost:4000/revenue
# {"total": 125000, "count": 450}
```
</Pre>
</CodeBlock>

That's it! Your query is now available as an HTTP endpoint with auto-generated OpenAPI docs at `http://localhost:4000/docs`.

## Deployment Models

### Embedded in Framework (Recommended for Web Apps)

Integrate hypequery directly into your web framework. Routes run on the **same port** as your application.

**Supported frameworks:**
- Next.js (Vercel adapter)
- Express
- Hono
- Any framework with standard Request/Response handlers

**Example: Next.js**

<CodeBlock>
<Pre>
```typescript
// app/api/hypequery/[...hq]/route.ts
import { api } from '@/analytics/queries';

export const runtime = 'nodejs';

export const GET = api.handler;
export const POST = api.handler;
```
</Pre>
</CodeBlock>

**Example: Express**

Use the Node adapter to mount hypequery alongside your existing routes:

<CodeBlock>
<Pre>
```typescript
// server.ts
import express from 'express';
import { createNodeHandler } from '@hypequery/serve/adapters/node';
import { api } from './analytics/queries';

const app = express();

// Mount hypequery at /api/analytics
app.use('/api/analytics', createNodeHandler(api.handler));

app.listen(3000);
```
</Pre>
</CodeBlock>

### Standalone Server

Run a dedicated hypequery server on its own port:

<CodeBlock>
<Pre>
```typescript
// src/analytics/server.ts
import { api } from './queries';

const server = await api.start({ port: 4000 });

// Optional: Add custom routes
server.app.get('/health', (req, res) => res.json({ ok: true }));
```
</Pre>
</CodeBlock>

Or use the CLI:

<CodeBlock>
<Pre>
```bash
# Development
npx hypequery dev src/analytics/queries.ts --port 4000

# Production
npx hypequery serve src/analytics/queries.ts --port 8080
```
</Pre>
</CodeBlock>

### Edge/Fetch Runtimes

Deploy to edge platforms using the standard Fetch API:

<CodeBlock>
<Pre>
```typescript
// Cloudflare Worker
import { api } from './analytics/queries';

export default {
  fetch(request: Request) {
    return api.handler(request);
  },
};

// Vercel Edge Function
import { api } from './analytics/queries';

export default function handler(request: Request) {
  return api.handler(request);
}
```
</Pre>
</CodeBlock>

## OpenAPI Documentation

Auto-generated OpenAPI specs are available at `/openapi.json`:

<CodeBlock>
<Pre>
```bash
curl http://localhost:4000/openapi.json
```
</Pre>
</CodeBlock>

You can also generate the spec programmatically:

<CodeBlock>
<Pre>
```typescript
import { api } from './analytics/queries';

// Get the OpenAPI document
const openApiDoc = api.openapi();

// Or build it with custom options
const doc = await api.buildOpenApiDocument({
  title: 'My Analytics API',
  version: '2.0.0',
  servers: [
    { url: 'https://api.example.com', description: 'Production' },
  ],
});
```
</Pre>
</CodeBlock>

## Documentation UI

Serve interactive API documentation:

<CodeBlock>
<Pre>
```typescript
import { api } from './analytics/queries';

// Get the HTML for Redoc
const docsHtml = await api.docsHtml();

// Or build it with custom options
const html = await api.buildDocsHtml({
  title: 'My API Docs',
  redocOptions: {
    theme: { colors: { primary: { main: '#FF6B6B' } } },
  },
});
```
</Pre>
</CodeBlock>

Then mount it wherever you want:

<CodeBlock>
<Pre>
```typescript
// Express example
app.get('/docs', (req, res) => {
  res.send(await api.docsHtml());
});
```
</Pre>
</CodeBlock>

## Custom Routes

Register individual queries with custom paths and methods:

<CodeBlock>
<Pre>
```typescript
import { api } from './analytics/queries';

// Register with custom path
api.route('/analytics/revenue', api.queries.revenue, { method: 'POST' });

// Register as GET
api.route('/health', api.queries.healthCheck, { method: 'GET' });

// Use query metadata from definition
api.route('/weekly', api.queries.weeklyRevenue);
```
</Pre>
</CodeBlock>
