---
layout: ../../../layouts/DocsLayout.astro
title: Next.js
description: Complete guide to integrating hypequery into a Next.js App Router project
---


import { Callout } from 'fumadocs-ui/components/callout';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { CodeBlock } from 'fumadocs-ui/components/codeblock';
import { Files, Folder, File } from 'fumadocs-ui/components/files';

# Next.js Integration

<Callout type="info" title="Runable Example">
You can find a runnable Next.js example in our [examples repo](https://github.com/hypequery/hypequery-examples)
</Callout>

This guide shows you how to add hypequery to an existing Next.js App Router project, expose analytics via API routes, and consume them with type-safe React hooks.

## What You'll Build

A taxi analytics dashboard using NYC taxi trip data. By the end of this guide:
- ✅ Type-safe ClickHouse queries for trip statistics
- ✅ HTTP API at `/api/analytics/*` with automatic OpenAPI
- ✅ Type-safe React hooks for client components
- ✅ Server-side execution with `api.run()` for SSR

**Example dataset:** NYC taxi trips with pickup/dropoff locations, fares, payment types, and distances.

## Prerequisites

- Existing Next.js 13+ App Router project
- ClickHouse instance (local or hosted)
- Node.js 18+
- Sample data: This guide uses the [NYC Taxi dataset](https://clickhouse.com/docs/en/getting-started/example-datasets/nyc-taxi) - adapt the queries for your own data

<Steps>
<Step>

### Install dependencies

<CodeBlock>
```bash
# Core packages
npm install @hypequery/clickhouse @hypequery/serve zod

# React hooks (for client components)
npm install @hypequery/react @tanstack/react-query

# CLI (required for type generation)
npm install -D @hypequery/cli
```
</CodeBlock>

</Step>

<Step>

### Configure environment variables

Create or update `.env.local`:

<CodeBlock>
```bash
# .env.local
CLICKHOUSE_HOST=http://localhost:8123
CLICKHOUSE_USERNAME=default
CLICKHOUSE_PASSWORD=your_password
CLICKHOUSE_DATABASE=default
```
</CodeBlock>

**Username env var:** We standardize on `CLICKHOUSE_USERNAME` (the name used in the ClickHouse samples). If your deployment exposes `CLICKHOUSE_USER`, set both variables or update `analytics/client.ts` to read the name your host provides.

**Shared config:** These env vars power everything—Next.js API routes, React hooks, and the `npx hypequery` CLI. Keep the names exactly as shown so every layer (including `hypequery dev`) reads the same ClickHouse connection without extra fallbacks.

**Important:** Add `.env.local` to `.gitignore` if not already there.

</Step>

<Step>

### Generate TypeScript types

Generate types from your ClickHouse schema:

<CodeBlock>
```bash
npx hypequery generate
```
</CodeBlock>

**What this does:**
- Connects to your ClickHouse instance
- Introspects your table schemas
- Generates `analytics/schema.ts` with TypeScript types

**Requires the CLI.** If `@hypequery/cli` isn't installed, `npx hypequery generate` will fail.

**This file is auto-generated.** Don't edit it manually - regenerate when your schema changes.

</Step>

<Step>

### Create ClickHouse client

Create `analytics/client.ts` (you write this manually):

<CodeBlock>
```typescript
import { createQueryBuilder } from '@hypequery/clickhouse';
import type { IntrospectedSchema } from './schema';

export const db = createQueryBuilder<IntrospectedSchema>({
  host: process.env.CLICKHOUSE_HOST!,
  username: process.env.CLICKHOUSE_USERNAME!,
  password: process.env.CLICKHOUSE_PASSWORD!,
  database: process.env.CLICKHOUSE_DATABASE!,
});
```
</CodeBlock>

**Note:** Place this in `analytics/` directory at project root (not `src/`).

**Using the NYC taxi dataset?** This example assumes you have the NYC taxi trips data loaded in ClickHouse. You can also adapt this to any other dataset by changing the table name and columns.

</Step>

<Step>

### Define analytics queries

Create `analytics/queries.ts` (you write this manually). We set `basePath: '/api/analytics'` so every registered query lands under the same prefix your Next.js route serves:

<CodeBlock>
```typescript
import { formatDateTime } from '@hypequery/clickhouse';
import { initServe } from '@hypequery/serve';
import { z } from 'zod';
import { db } from './client';

// Initialize with context factory
const { define, queries, query } = initServe({
  context: () => ({ db }),
});

// Define your analytics catalog
export const api = define({
  basePath: '/api/analytics',
  queries: queries({
    dailyStats: query
      .describe('Daily trip counts and revenue')
      .input(z.object({
        startDate: z.string().datetime(),
        endDate: z.string().datetime(),
      }))
      .output(z.array(z.object({
        day: z.string(),
        trip_count: z.number(),
        total_revenue: z.number(),
        avg_fare: z.number(),
        avg_distance: z.number(),
      })))
      .query(({ ctx, input }) =>
        ctx.db
          .table('trips')
          .select([
            formatDateTime('pickup_datetime', 'Y-MM-dd', { alias: 'day' }),
          ])
          .where('pickup_datetime', 'gte', input.startDate)
          .where('pickup_datetime', 'lte', input.endDate)
          .groupBy(['day'])
          .count('trip_id', 'trip_count')
          .sum('total_amount', 'total_revenue')
          .avg('fare_amount', 'avg_fare')
          .avg('trip_distance', 'avg_distance')
          .orderBy('day', 'ASC')
          .execute()
      ),
  }),
});

// Register HTTP routes (REQUIRED for HTTP access)
api.route('/daily-stats', api.queries.dailyStats, { method: 'POST' });
```
</CodeBlock>

**Key points:**
- Use `ctx.db` (not `db`) inside query functions
- Always call `.execute()` at the end
- Return the promise (don't await inside query function)
- Register routes with `api.route()` to expose via HTTP
- Set `basePath` once if you want all routes under a common prefix (e.g., `/api/analytics`).

</Step>

<Step>

### Create Next.js API route

Create `app/api/analytics/[...path]/route.ts` (you write this manually):

<CodeBlock>
```typescript
import { api } from '@/analytics/queries';
import { createFetchHandler } from '@hypequery/serve/adapters/fetch';

// Adapt hypequery's handler to the App Router fetch API
const handler = createFetchHandler(api.handler);

// Force Node.js runtime (not Edge)
export const runtime = 'nodejs';

// Export the unified handler for all HTTP methods
export const GET = handler;
export const POST = handler;
export const OPTIONS = handler;
```
</CodeBlock>

**What this does:**
- Catch-all route handles `/api/analytics/*`
- `createFetchHandler` ensures App Router returns a proper `Response` for each verb
- Routes defined with `api.route()` (prefixed by `basePath`) are now accessible via HTTP

**Path alias setup:**
If `@/analytics/queries` doesn't work, configure in `tsconfig.json`:

<CodeBlock>
```json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./*"]
    }
  }
}
```
</CodeBlock>

</Step>

<Step>

### Set up React Query provider

Create `app/providers.tsx` (you write this manually):

<CodeBlock>
```tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode, useState } from 'react';

export function Providers({ children }: { children: ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
```
</CodeBlock>

Wrap your app in `app/layout.tsx`:

<CodeBlock>
```tsx
import { Providers } from './providers';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```
</CodeBlock>

**This step is REQUIRED** - React Query hooks won't work without the provider.

</Step>

<Step>

### Create typed hooks

Create `lib/analytics.ts` (you write this manually). Because this file exports client hooks, mark it as a client module and only import the server API for types:

<CodeBlock>
```typescript
'use client';

import { createHooks } from '@hypequery/react';
import { InferApiType } from '@hypequery/serve';
import type { api } from '@/analytics/queries';

// Automatically extract types from your API definition
type AnalyticsApi = InferApiType<typeof api>;

export const { useQuery, useMutation } = createHooks<AnalyticsApi>({
  baseUrl: '/api/analytics',
  config: {
    dailyStats: { method: 'POST' },
  },
});
```
</CodeBlock>

**What this does:**
- `'use client';` ensures the module can use React Query on the client while `import type` keeps the `api` reference type-only.
- `InferApiType` extracts types from your query definitions for end-to-end safety.
- `config` supplies the HTTP method map that `createHooks` needs (client modules can't import the runtime `api` object, so we declare the methods manually).

</Step>

<Step>

### Use in client components

Create `app/dashboard/page.tsx`:

<CodeBlock>
```tsx
'use client';

import { useQuery } from '@/lib/analytics';

export default function DashboardPage() {
  const { data: dailyStats, isLoading, error } = useQuery('dailyStats', {
    startDate: '2024-01-01T00:00:00Z',
    endDate: '2024-01-31T23:59:59Z',
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>NYC Taxi Dashboard</h1>

      <section>
        <h2>Daily Statistics</h2>
        {dailyStats?.map((day) => (
          <div key={day.day}>
            <strong>{day.day}</strong>: {day.trip_count.toLocaleString()} trips,
            ${day.total_revenue.toLocaleString()} revenue (avg ${day.avg_fare.toFixed(2)}/trip,
            {day.avg_distance.toFixed(1)} mi)
          </div>
        ))}
      </section>
    </div>
  );
}
```
</CodeBlock>

**Type safety:**
- Query names are autocompleted (try `'dailyStats'` and see TS guide you)
- Input types are enforced (TypeScript error if you pass wrong shape)
- Output types are inferred (no need to manually type `data`)

</Step>

<Step>

### Use in server components (optional)

For Server Components or API routes, use `api.run()` directly:

<CodeBlock>
```tsx
// app/report/page.tsx
import { api } from '@/analytics/queries';

export default async function ReportPage() {
  // Execute directly on the server
  const stats = await api.run('dailyStats', {
    input: {
      startDate: '2024-01-01T00:00:00Z',
      endDate: '2024-01-31T23:59:59Z',
    },
  });

  const totalTrips = stats.reduce((sum, day) => sum + Number(day.trip_count), 0);
  const totalRevenue = stats.reduce((sum, day) => sum + Number(day.total_revenue), 0);

  return (
    <div>
      <h1>Monthly Report</h1>
      <p>Total Trips: {totalTrips.toLocaleString()}</p>
      <p>Total Revenue: ${totalRevenue.toLocaleString()}</p>
      <h2>Daily Breakdown</h2>
      <pre>{JSON.stringify(stats, null, 2)}</pre>
    </div>
  );
}
```
</CodeBlock>

**Type inference caveat:** `api.run()` executes the query directly against ClickHouse and returns raw client values (numbers often come back as strings). Zod output schemas are enforced in the HTTP handler + React hooks path, but server-side `api.run()` currently doesn't narrow those types—cast or coerce as needed (see `Number(...)` above).

**When to use `api.run()` vs hooks:**
- Server Components: Use `api.run()`
- Server Actions: Use `api.run()`
- Client Components: Use `useQuery` hooks
- API Routes: Use `api.run()` or return `api.handler`

</Step>

</Steps>

## Testing Locally

<CodeBlock>
```bash
# Start Next.js dev server
npm run dev
# Your API is now at: http://localhost:3000/api/analytics/*

# Optional: Run hypequery dev server for interactive docs
npx hypequery dev analytics/queries.ts
# Docs at: http://localhost:4000/docs
```
</CodeBlock>

## Testing Your API

<CodeBlock>
```bash
# Test daily stats endpoint
curl -X POST http://localhost:3000/api/analytics/daily-stats \
  -H "Content-Type: application/json" \
  -d '{"startDate":"2024-01-01T00:00:00Z","endDate":"2024-01-31T23:59:59Z"}'

# View OpenAPI spec
curl http://localhost:3000/api/analytics/openapi.json
```
</CodeBlock>

## Deployment (Vercel)

No special configuration needed! Deploy as usual:

<CodeBlock>
```bash
vercel deploy
```
</CodeBlock>

## Project Structure

After following this guide, your structure should look like:

<Files>
  <Folder name="your-nextjs-app" defaultOpen>
    <Folder name="analytics" defaultOpen>
      <File name="schema.ts (Auto-generated by `hypequery generate`)" />
      <File name="client.ts (You write this)" />
      <File name="queries.ts (You write this)" />
    </Folder>
    <Folder name="app">
      <Folder name="api">
        <Folder name="analytics">
          <Folder name="[...path]">
            <File name="route.ts (You write this)" />
          </Folder>
        </Folder>
      </Folder>
      <Folder name="dashboard">
        <File name="page.tsx (You write this - client component)" />
      </Folder>
      <File name="providers.tsx (You write this)" />
      <File name="layout.tsx (You update this)" />
    </Folder>
    <Folder name="lib">
      <File name="analytics.ts (You write this - React hooks)" />
    </Folder>
    <File name=".env.local (You create this)" />
    <File name="tsconfig.json (Configure path aliases)" />
  </Folder>
</Files>

## Related

- [React Hooks Reference](/docs/reference/react) - Complete React hooks API
- [Serve API Reference](/docs/reference/serve) - Full serve framework API
- [Deployment Guide](/docs/deploy/http-openapi) - Production deployment patterns
