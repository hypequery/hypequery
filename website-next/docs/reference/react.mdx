---
layout: ../../../layouts/DocsLayout.astro
title: React hooks
description: Use @hypequery/react to generate typed hooks from your hypequery API
---

import { CodeBlock } from 'fumadocs-ui/components/codeblock';

<div class="prose">

# React hooks

Use `@hypequery/react` to generate type-safe hooks (`useQuery`, `useMutation`) backed by TanStack Query. Bring your existing `defineServe` API types and wire them into your React app without duplicating schemas.

## Installation

<CodeBlock>
```bash
npm install @hypequery/react @tanstack/react-query
```
</CodeBlock>

Peer dependencies: `react@^18`, `@tanstack/react-query@^5`.

## Setup

### Option 1: Automatic Type Inference (Recommended)

Use `InferApiType` to automatically extract types from your API definition:

<CodeBlock>
```ts
// lib/analytics.ts
import { createHooks } from '@hypequery/react';
import { InferApiType } from '@hypequery/serve';
import type { api } from '@/analytics/queries';

// Automatic type inference - no manual type definition needed!
type Api = InferApiType<typeof api>;

export const { useQuery, useMutation } = createHooks<Api>({
  baseUrl: '/api', // where your hypequery routes live
});
```
</CodeBlock>

This eliminates the need to manually define and maintain a separate type for your API.

### Option 2: Manual Type Definition

If you prefer to manually define your API types:

<CodeBlock>
```ts
// lib/analytics.ts
import { createHooks } from '@hypequery/react';

type Api = {
  weeklyRevenue: {
    input: { startDate: string };
    output: { total: number };
  };
  // ... other queries
};

export const { useQuery, useMutation } = createHooks<Api>({
  baseUrl: '/api',
});
```
</CodeBlock>

Wrap your app:

<CodeBlock>
```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

export function AppProviders({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
```
</CodeBlock>

## `useQuery`

<CodeBlock>
```tsx
const { data, error, isLoading } = useQuery('weeklyRevenue', {
  startDate: '2025-01-01',
});
```
</CodeBlock>

- `name` is one of your API keys
- `input` matches the endpoint’s `inputSchema`
- Options mirror TanStack Query (`staleTime`, `enabled`, etc.)

## `useMutation`

<CodeBlock>
```tsx
const rebuild = useMutation('rebuildMetrics');
rebuild.mutate({ force: true });
```
</CodeBlock>

Mutations share the same typed `input`/`output` data.

## `createHooks` API

`createHooks` accepts a config object that controls base URL, HTTP method overrides, and request customization.

<CodeBlock>
```ts
interface CreateHooksConfig<TApi> {
  baseUrl: string;                           // Required: base URL for your serve routes
  fetchFn?: typeof fetch;                    // Optional: custom fetch (e.g., auth/tenant headers)
  headers?: Record<string, string> | (() => Record<string, string>); // Optional: default headers or a resolver function
  config?: Record<string, { method?: string }>; // Optional: per-route HTTP method overrides
  api?: TApi;                                // Optional: API object to infer HTTP methods automatically
}
```
</CodeBlock>

Use `fetchFn` when you need full control. Use `headers` when values are static, or pass a function when you need per-request headers without rewriting `fetchFn`.

<CodeBlock>
```ts
const { useQuery, useMutation } = createHooks<Api>({
  baseUrl: '/api',
  headers: () => {
    const tenantKey = getTenantKey();
    return tenantKey ? { 'x-tenant-key': tenantKey } : {};
  },
});
```
</CodeBlock>

## HTTP Method Configuration

By default, hooks issue `GET` requests (matching the default route method). Override them per query when you need `POST`, `PUT`, etc.:

<CodeBlock>
```ts
import { createHooks } from '@hypequery/react';
import { InferApiType } from '@hypequery/serve';
import type { api } from '@/analytics/queries';

type Api = InferApiType<typeof api>;

export const { useQuery, useMutation } = createHooks<Api>({
  baseUrl: '/api',
  config: {
    weeklyRevenue: { method: 'GET' },    // Read-only queries
    tripStats: { method: 'GET' },
    rebuildMetrics: { method: 'POST' },  // Write operations
  },
});
```
</CodeBlock>

### Advanced: Auto-config from Server

You don’t have to maintain the verbs manually—`@hypequery/serve` can tell the client which HTTP method each route uses.

**Option A – share the server module (Next.js / Remix):**

When your React code can import the server bundle (e.g., Next.js App Router), just pass `api` directly:

<CodeBlock>
```ts
import { createHooks } from '@hypequery/react';
import { InferApiType } from '@hypequery/serve';
import { api } from '@/analytics/queries';

type Api = InferApiType<typeof api>;

export const { useQuery, useMutation } = createHooks<Api>({
  baseUrl: '/api/hypequery',
  api, // method metadata is extracted automatically
});
```
</CodeBlock>

**Option B – expose a config endpoint (SPAs / Vite):**

If your frontend can’t import the server module, publish the config once and hydrate `createHooks` with it:

<CodeBlock>
```ts
// app/api/hypequery-config/route.ts
import { extractClientConfig } from '@hypequery/serve';
import { api } from '@/analytics/queries';

export function GET() {
  return Response.json(extractClientConfig(api));
}
```
</CodeBlock>

<CodeBlock>
```ts
// lib/analytics.ts
import { createHooks } from '@hypequery/react';
import { InferApiType } from '@hypequery/serve';
import type { api } from '@/analytics/queries';

type Api = InferApiType<typeof api>;

let hooksPromise: Promise<ReturnType<typeof createHooks<Api>>> | null = null;

export function getHypequeryHooks() {
  if (!hooksPromise) {
    hooksPromise = fetch('/api/hypequery-config')
      .then((res) => res.json())
      .then((config) =>
        createHooks<Api>({ baseUrl: '/api/hypequery', config })
      );
  }
  return hooksPromise;
}
```
</CodeBlock>

Call `await getHypequeryHooks()` once during app bootstrap (e.g., inside a top-level provider) and reuse the returned `useQuery`/`useMutation` instances throughout your app.

## Advanced options

Both hooks accept the underlying TanStack options, so you can control `staleTime`, retries, invalidation, manual `queryClient` access, etc.

## Error handling

Errors bubble through TanStack Query’s `error` state. Validation errors from hypequery endpoints arrive as structured JSON (status code + body). Network failures throw standard `fetch` errors.

## When to use it

- SPA dashboards needing cached queries
- Next.js / Remix apps already using TanStack Query
- Agents or components calling hypequery APIs inline

If you don’t need React hooks, you can call `api.execute` directly on the server or use the HTTP API as-is.

</div>
