---
title: Serve API
description: API guide for defineServe, ServeConfig, and related utilities in @hypequery/serve
---

import { CodeBlock } from 'fumadocs-ui/components/codeblock';

import { TypeTable } from 'fumadocs-ui/components/type-table';

# `@hypequery/serve` reference

The serve package turns your metrics into HTTP endpoints, docs, and OpenAPI artifacts. This page lists every exported primitive so you can wire the runtime intentionally. For a conceptual tour of delivery options, read the [Serve runtime overview](/docs/serve-runtime) first.

## `defineServe`

<CodeBlock>
```typescript
import { defineServe } from '@hypequery/serve';

export const api = defineServe({
  queries: {
    activeUsers: {
      query: async ({ ctx }) => ctx.db.table('users').where('status', 'eq', 'active').count(),
      inputSchema: z.object({ region: z.string().optional() }),
      outputSchema: z.object({ total: z.number() }),
      method: 'POST',
      cacheTtlMs: 5_000,
      tags: ['users'],
      auth: async ({ request }) => verifySession(request),
    },
  },
  basePath: '/api/analytics',
  tenant: { extract: (auth) => auth?.accountId, column: 'account_id', mode: 'auto-inject' },
  auth: async ({ request }) => getAuthContext(request),
  middlewares: [logRequests],
  docs: { enabled: true, path: '/docs', title: 'Analytics API' },
  openapi: { enabled: true, path: '/openapi.json', version: '1.2.0', info: { title: 'Analytics' } },
  context: async ({ request }) => ({ requestId: request.headers['x-request-id'] }),
  hooks: {
    onRequestStart: ({ queryKey, requestId }) => trace.begin(requestId, queryKey),
    onRequestEnd: ({ durationMs, queryKey }) => metrics.record(queryKey, durationMs),
    onError: ({ error, queryKey }) => logger.error(error, { queryKey }),
  },
});
```
</CodeBlock>

### `ServeConfig` options

<TypeTable
  type={{
    queries: {
      type: 'ServeQueriesMap',
      required: true,
      description: 'Map of query definitions (either `ServeQueryConfig` objects or executable functions).',
    },
    basePath: {
      type: 'string',
      default: '"/api/analytics"',
      description: 'Prefix applied to every generated route; docs/OpenAPI inherit this prefix.',
    },
    middlewares: {
      type: 'ServeMiddleware[]',
      default: '[]',
      description: 'Global middleware stack executed before every endpoint.',
    },
    auth: {
      type: 'AuthStrategy | AuthStrategy[]',
      default: '[]',
      description: 'One or more strategies that produce the `auth` context. Missing/failed strategies trigger `onAuthFailure`.',
    },
    tenant: {
      type: 'TenantConfig',
      default: 'undefined',
      description: 'Global tenant isolation config; individual queries can override or opt out.',
    },
    docs: {
      type: 'DocsOptions',
      default: '{ enabled: true, path: "/docs" }',
      description: 'Built-in Redoc UI served at `${basePath}${path}`. Disable if you host your own docs.',
    },
    openapi: {
      type: 'OpenApiOptions',
      default: '{ enabled: true, path: "/openapi.json" }',
      description: 'OpenAPI JSON served at `${basePath}${path}`; point custom UIs/clients here.',
    },
    context: {
      type: 'ServeContextFactory',
      default: 'undefined',
      description: 'Object or factory merged into `ctx` for handlers/middlewares.',
    },
    hooks: {
      type: 'ServeLifecycleHooks',
      default: '{}',
      description: 'Lifecycle callbacks (`onRequestStart`, `onRequestEnd`, `onError`, `onAuthFailure`).',
    },
    queryLogging: {
      type: "boolean | 'json' | ServeQueryEventCallback",
      default: 'undefined',
      description: "Opt-in query logging. `true` logs human-readable text, `'json'` logs structured JSON for aggregators (Datadog, CloudWatch), or pass a custom `(event) => void`. Disabled (zero overhead) when omitted.",
    },
    slowQueryThreshold: {
      type: 'number',
      default: 'undefined',
      description: 'Warn via `console.warn` when a completed query exceeds this many milliseconds. Works independently of `queryLogging`.',
    },
  }}
/>

## Query definitions (`ServeQueryConfig`)

You can describe endpoints declaratively or pass executable functions directly. When using the config form the following fields are available:

<TypeTable
  type={{
    query: {
      type: 'ExecutableQuery',
      required: true,
      description: 'Resolver (`({ input, ctx }) => result`) or legacy `(input, ctx)` function/object with `run`.',
    },
    method: {
      type: 'HttpMethod',
      default: '"GET"',
      description: 'HTTP verb for the endpoint.',
    },
    name: {
      type: 'string',
      default: 'query key',
      description: 'Human-readable label shown in docs, OpenAPI, and `api.describe()`.',
    },
    inputSchema: {
      type: 'Zod schema',
      default: 'z.any()',
      description: 'Validation + OpenAPI shape for request payload.',
    },
    outputSchema: {
      type: 'Zod schema',
      default: 'z.any()',
      description: 'Validation + OpenAPI shape for response payload.',
    },
    middlewares: {
      type: 'ServeMiddleware[]',
      default: '[]',
      description: 'Endpoint-specific middleware stack (runs after global middlewares).',
    },
    auth: {
      type: 'AuthStrategy | null',
      default: 'inherits global',
      description: 'Per-endpoint auth override; returning `null` rejects the request.',
    },
    tenant: {
      type: 'TenantConfigOverride',
      default: 'inherits global',
      description: 'Per-endpoint tenant overrides merged with the global config. If no global tenant config is set, include extract in the override.',
    },
    cacheTtlMs: {
      type: 'number | null',
      default: 'null',
      description: 'Sets `cache-control` headers / exposes cache helpers.',
    },
    summary: {
      type: 'string',
      default: 'undefined',
      description: 'Metadata surfaced in OpenAPI and docs.',
    },
    description: {
      type: 'string',
      default: 'undefined',
      description: 'Metadata surfaced in OpenAPI and docs.',
    },
    tags: {
      type: 'string[]',
      default: 'undefined',
      description: 'Metadata surfaced in OpenAPI and docs.',
    },
    custom: {
      type: 'Record<string, unknown>',
      default: 'undefined',
      description: 'Arbitrary metadata also emitted via `api.describe()`.',
    },
  }}
/>

Executable functions can be passed directly in `queries` when you just need a handler—`defineServe` wraps them in a default configuration.

## Builder API

`defineServe` returns a `ServeBuilder` with composable runtime helpers:

<TypeTable
  type={{
    route: {
      type: '(path, endpoint, options?) => void',
      description: 'Register additional paths/methods for an existing endpoint. Lets you reuse the same query behind multiple URLs.',
    },
    use: {
      type: '(middleware) => void',
      description: 'Push a global middleware executed before every handler. Useful for logging, tracing, or mutating context.',
    },
    useAuth: {
      type: '(strategy) => void',
      description: 'Append an `AuthStrategy`. If at least one strategy exists the docs/OpenAPI metadata reflect `requiresAuth`.',
    },
    execute: {
      type: '(key, { input, context, request }) => Promise<Result>',
      description: 'Run a query in-process without HTTP. Perfect for SSR, cron jobs, or tests. Throws when the endpoint returns an error response.',
    },
    run: {
      type: '(key, options?) => Promise<Result>',
      description: 'Alias of `builder.execute` (same signature) for in-process execution.',
    },
    describe: {
      type: '() => EndpointDescription[]',
      description: 'Returns a structured description (key, path, method, metadata) for downstream tooling.',
    },
    queryLogger: {
      type: 'ServeQueryLogger',
      description: '`ServeQueryLogger` instance for subscribing to endpoint execution events. See [Observability](#observability) below.',
    },
    handler: {
      type: 'ServeHandler',
      description: 'Low-level `ServeHandler` function you can pass into any adapter (Node, Fetch, Edge).',
    },
    start: {
      type: '(options?) => { stop: () => void }',
      description: 'Convenience helper that starts the default Node server (internally uses `startNodeServer`). Resolves to `{ stop() }`.',
    },
  }}
/>

## Utilities

### `normalizeHeaderMap`

Normalize a plain header object to lower-case keys so you can do case-insensitive header lookups in auth strategies or middleware.

<CodeBlock>
```typescript
import { normalizeHeaderMap } from '@hypequery/serve';

const headers = normalizeHeaderMap(request.headers);
const token = headers['authorization'];
```
</CodeBlock>

## Runtime helpers

- **`serveDev(api, options?)`** – Launches a Node server (defaults to `localhost:4000`) with query logging always enabled (logs completed/errored requests to the terminal). Accepts `port`, `hostname`, `signal`, `logger`, and `quiet`.
- **Node adapter** – `createNodeHandler` converts a `ServeHandler` into a Node `(req, res)` listener, and `startNodeServer` boots an HTTP server with graceful shutdown helpers.
- **Fetch/edge adapter** – `createFetchHandler` produces a `(request: Request) => Response` for edge runtimes, Cloudflare Workers, Remix loaders, etc.
- **Vercel adapters** – `createVercelEdgeHandler` wraps the fetch adapter for Edge Functions, while `createVercelNodeHandler` reuses the Node adapter for the Node runtime.

## Documentation + OpenAPI utilities

- **`buildOpenApiDocument(endpoints, options?)`** – Generates an OpenAPI 3.1 document from any list of `ServeEndpoint`s. Use it to persist specs or feed schema registries.
- **`buildDocsHtml(openapiUrl, docsOptions?)`** – Produces the Redoc-powered HTML served at `/docs`. You can host the markup yourself by calling this helper directly.

## Observability

Every response includes an `X-Request-Id` header (generated or echoed from the incoming `x-request-id` / `x-trace-id`). Use it to correlate HTTP responses with logs.

### Query logging

Enable query logging to observe endpoint execution in production or during development.

<CodeBlock>
```typescript
// Human-readable text to stdout
const api = defineServe({ queries, queryLogging: true });
//   ✓ GET /api/analytics/revenue → 200 (12ms)
//   ✗ POST /api/analytics/report → 500 (3ms) — Connection refused

// Structured JSON for log aggregators
const api = defineServe({ queries, queryLogging: 'json' });
// {"level":"info","msg":"GET /api/analytics/revenue","requestId":"...","endpoint":"revenue","status":200,"durationMs":12,"timestamp":"..."}

// Custom callback (ship to Datadog, Sentry, etc.)
const api = defineServe({
  queries,
  queryLogging: (event) => {
    datadogLogs.logger.info(event.endpointKey, {
      duration: event.durationMs,
      status: event.responseStatus,
    });
  },
});
```
</CodeBlock>

When `queryLogging` is omitted (the default), no listeners are registered and the emit path is skipped entirely — zero runtime overhead.

In development, `serveDev()` always subscribes its own terminal logger regardless of this setting.

### Slow query warnings

Flag queries that exceed a duration threshold:

<CodeBlock>
```typescript
const api = defineServe({
  queries,
  queryLogging: 'json',
  slowQueryThreshold: 2000, // ms
});
// console.warn: [hypequery/slow-query] GET /api/analytics/report (report) took 3400ms (threshold: 2000ms)
```
</CodeBlock>

`slowQueryThreshold` registers an independent listener that calls `console.warn`, so it works alongside any `queryLogging` mode (or even without it — set `slowQueryThreshold` alone if you only want warnings).

### Programmatic access

Use `api.queryLogger` to subscribe manually:

<CodeBlock>
```typescript
const api = defineServe({ queries });

// Subscribe to all events
const unsubscribe = api.queryLogger.on((event) => {
  if (event.status === 'completed') {
    histogram.record(event.durationMs);
  }
});

// Check listener count (for diagnostics)
api.queryLogger.listenerCount; // 1

// Clean up
unsubscribe();
```
</CodeBlock>

### `ServeQueryEvent`

<TypeTable
  type={{
    requestId: {
      type: 'string',
      description: 'Unique request identifier (matches `X-Request-Id` header).',
    },
    endpointKey: {
      type: 'string',
      description: 'The query key from `defineServe({ queries: { ... } })`.',
    },
    path: {
      type: 'string',
      description: 'HTTP path of the endpoint.',
    },
    method: {
      type: 'string',
      description: 'HTTP method (`GET`, `POST`, etc.).',
    },
    status: {
      type: "'started' | 'completed' | 'error'",
      description: 'Lifecycle phase.',
    },
    startTime: {
      type: 'number',
      description: '`Date.now()` when the request began.',
    },
    endTime: {
      type: 'number?',
      description: '`Date.now()` when the request finished (completed/error only).',
    },
    durationMs: {
      type: 'number?',
      description: 'Wall-clock duration in milliseconds (completed/error only).',
    },
    input: {
      type: 'unknown?',
      description: 'Parsed input payload.',
    },
    responseStatus: {
      type: 'number?',
      description: 'HTTP status code of the response.',
    },
    error: {
      type: 'Error?',
      description: 'Error instance (error events only).',
    },
    result: {
      type: 'unknown?',
      description: 'Query result (completed events only).',
    },
  }}
/>

### Formatting utilities

Two built-in formatters are exported for use in custom logging setups:

<CodeBlock>
```typescript
import { formatQueryEvent, formatQueryEventJSON } from '@hypequery/serve';

// Human-readable:  "  ✓ GET /api/analytics/revenue → 200 (12ms)"
formatQueryEvent(event);

// Structured JSON:  '{"level":"info","msg":"GET /api/analytics/revenue",...}'
formatQueryEventJSON(event);
```
</CodeBlock>

Both return `null` for `started` events (only format completions and errors).

## Types worth knowing

- **`ServeMiddleware`** – `(ctx, next) => result`. Mutate context, emit logs, wrap cache, etc.
- **`AuthStrategy`** – `({ request, endpoint }) => auth \| null`. Compose multiple strategies to support API keys, JWTs, and tenant lookups.
- **`TenantConfig`** – Enforce tenant isolation by extracting IDs, requiring presence, and optionally auto-injecting filters.
- **`ServeLifecycleHooks`** – Observe every request for logging/metrics/tracing.
- **`ServeQueryLogger`** – Event emitter for endpoint executions. Exposes `.on(callback)`, `.listenerCount`, and `.removeAll()`.
- **`ServeQueryEvent`** – Event payload emitted during each endpoint lifecycle (started, completed, error). See [Observability](#observability) for the full field list.
- **`ErrorEnvelope`** – Shape of errors returned from hypequery endpoints:

  <CodeBlock>
  ```json
  {
    "error": {
      "type": "VALIDATION_ERROR" | "UNAUTHORIZED" | "QUERY_FAILURE" | "CLICKHOUSE_UNREACHABLE" | "RATE_LIMITED" | "NOT_FOUND" | "INTERNAL_SERVER_ERROR",
      "message": "Human-friendly summary",
      "details": {
        "issues": [ /* zod validation errors */ ],
        "reason": "missing_credentials",
        "queryId": "...",
        // ... provider-specific metadata
      }
    }
  }
  ```
  </CodeBlock>

  Use this structure when surfacing errors to clients or agents so they can branch on the `type` field.

With these pieces you can embed analytics directly in your app, expose an HTTP API, or plug the same definitions into edge runtimes without rewriting handlers.
