---
layout: ../../../layouts/DocsLayout.astro
title: Subqueries & CTEs - hypequery
description: Compose reusable subqueries, common table expressions, and raw SQL inside defineServe
---

# Subqueries & CTEs

`defineServe` exposes every ClickHouse power tool, including Common Table Expressions (CTEs), nested subqueries, and raw SQL escape hatches. Use them when a single builder chain gets unwieldy.

## Using a builder as a CTE

You can pass any builder chain into `withCTE` by building it with the same `ctx.db` instance.

```ts
import { defineServe } from '@hypequery/clickhouse';

export const api = defineServe({
  queries: {
    ordersWithActiveUsers: {
      query: ({ ctx }) => {
        const activeUsers = ctx.db
          .table('users')
          .select(['id', 'user_name', 'email'])
          .where('status', 'eq', 'active');

        return ctx.db
          .table('orders')
          .withCTE('active_users', activeUsers)
          .select(['orders.id', 'orders.total', 'active_users.user_name'])
          .innerJoin('active_users', 'user_id', 'active_users.id');
      },
    },
  },
});
```

Generated SQL:

```
WITH active_users AS (
  SELECT id, user_name, email
  FROM users
  WHERE status = 'active'
)
SELECT orders.id, orders.total, active_users.user_name
FROM orders
INNER JOIN active_users ON orders.user_id = active_users.id
```

## Raw SQL as a CTE

Skip the fluent builder when you already have a tuned SQL snippet.

```ts
export const api = defineServe({
  queries: {
    ordersWithMonthlyTotals: {
      query: ({ ctx }) =>
        ctx.db
          .table('orders')
          .withCTE(
            'monthly_totals',
            'SELECT user_id, toStartOfMonth(created_at) AS month, SUM(total) AS monthly_sum FROM orders GROUP BY user_id, month',
          )
          .select(['orders.id', 'orders.created_at', 'monthly_totals.monthly_sum'])
          .innerJoin('monthly_totals', 'user_id', 'monthly_totals.user_id')
          .where('orders.created_at', 'gte', 'monthly_totals.month'),
    },
  },
});
```

## Multiple CTEs

Chain as many `withCTE` calls as you need. They’re evaluated in the order you register them.

```ts
export const api = defineServe({
  queries: {
    engagedUsers: {
      query: ({ ctx }) =>
        ctx.db
          .table('events')
          .withCTE(
            'daily_users',
            'SELECT user_id, toDate(timestamp) AS day, COUNT(*) AS event_count FROM events GROUP BY user_id, day',
          )
          .withCTE(
            'active_users',
            'SELECT user_id, COUNT(DISTINCT day) AS active_days FROM daily_users GROUP BY user_id HAVING active_days > 7',
          )
          .select(['events.*'])
          .innerJoin('active_users', 'user_id', 'active_users.user_id'),
    },
  },
});
```

## Raw SQL expressions

Use `.raw()` for HAVING clauses or other expressions the fluent API doesn’t cover yet.

```ts
export const api = defineServe({
  queries: {
    whaleCustomers: {
      query: ({ ctx }) =>
        ctx.db
          .table('orders')
          .select(['user_id'])
          .sum('total', 'total_spent')
          .groupBy(['user_id'])
          .raw('SUM(total) > 1000')
          .raw('COUNT(DISTINCT product_id) >= 3'),
    },
  },
});
```

Generates:

```
SELECT user_id, SUM(total) AS total_spent
FROM orders
GROUP BY user_id
HAVING SUM(total) > 1000 AND COUNT(DISTINCT product_id) >= 3
```

## Limitations and workarounds

ClickHouse rejects nested subqueries inside `WHERE` clauses when they can be modeled as joins/CTEs. Reach for a CTE to mimic `IN (SELECT ...)` logic.

```ts
export const api = defineServe({
  queries: {
    productsWithActiveCategories: {
      query: ({ ctx }) =>
        ctx.db
          .table('products')
          .withCTE('active_categories', 'SELECT id FROM categories WHERE active = 1')
          .select(['products.*'])
          .innerJoin('active_categories', 'category_id', 'active_categories.id'),
    },
  },
});
```

This replaces:

```
SELECT *
FROM products
WHERE category_id IN (SELECT id FROM categories WHERE active = 1)
```
