---
layout: ../../../layouts/DocsLayout.astro
title: Advanced Query Features
description: Quick reference for subqueries, helper methods, streaming, and logging in hypequery
---

# Advanced Query Features

Miss the older niche docs (subqueries, helper helpers, streaming, logging)? This page condenses their greatest hits so you can scan the features in one place, then jump into the detailed guides when you need them.

## Subqueries & CTEs

Use `.withCTE(name, builderOrSQL)` to register a reusable subquery and join it just like a table:

```typescript
const activeUsers = db
  .table('users')
  .select(['id', 'name'])
  .where('status', 'eq', 'active');

const revenue = await db
  .table('orders')
  .withCTE('active_users', activeUsers)
  .leftJoin('active_users', 'orders.user_id', 'active_users.id')
  .sum('orders.total', 'total_spent')
  .groupBy('active_users.name')
  .execute();
```

Need inline SQL instead? Pass a string or `raw()` expression to the same helper. Multiple CTEs are supported—just keep chaining `withCTE()`. For deeper patterns (IN-style subqueries, raw HAVING clauses, limitations), see [Subqueries & CTEs](/docs/define/subqueries).

## Helper methods

The builder exposes utility hooks for inspecting, configuring, and debugging queries:

```typescript
const query = db
  .table('orders')
  .where('total', 'gte', 1000)
  .settings({ max_execution_time: 30 })
  .debug();

const sql = query.toSQL();
const { sql: prepared, parameters } = query.toSQLWithParams();
const config = query.getConfig();
```

- `.settings({...})` – pass ClickHouse settings (timeouts, thread limits, memory caps).
- `.debug()` – log SQL, parameters, and cache info in dev.
- `.getConfig()` – inspect the internal builder state (helpful for custom tooling).
- `.raw()` – inject complex predicates when the fluent API is not enough.

## Streaming huge result sets

Process large tables without loading them entirely into memory:

```typescript
const stream = await db
  .table('events')
  .select(['timestamp', 'event_type'])
  .where('timestamp', 'gte', '2024-01-01')
  .stream();

const reader = stream.getReader();
try {
  while (true) {
    const { done, value: rows } = await reader.read();
    if (done) break;
    rows.forEach((row) => ingest(row));
  }
} finally {
  reader.releaseLock();
}
```

Prefer a callback API? `await db.table('events').streamForEach((row) => { ... })` handles batching internally. Streaming plays nicely with joins, aggregates, and logging—perfect for export jobs or AI agents that need staged input.

## Structured logging

hypequery ships a Logger you can wire into your observability stack:

```typescript
import { logger } from '@hypequery/clickhouse';

logger.configure({
  level: 'debug',
  enabled: true,
  onQueryLog: (log) => {
    console.info(`[${log.status}] ${log.query} (${log.duration}ms)`);
  },
});

const unsubscribe = logger.subscribeToQuery('reports#weekly', (log) => {
  telemetry.track(log);
});

await db
  .table('reports')
  .select(['id'])
  .execute({ queryId: 'reports#weekly' });

unsubscribe();
```

Every log event includes SQL, timing, row counts, cache metadata, and errors. You can temporarily mute logging (`logger.configure({ enabled: false })`), bump verbosity, or route events to your own logger/metrics pipeline. Dive into [Logging Support](/docs/operate/observability) for the full API.

---

**Need more?**

- [Subqueries & CTEs](/docs/define/subqueries)
- [Helper Methods](/docs/define/helper-methods)
- [Streaming APIs](/docs/define/query-building#running-queries)
- [Logging Support](/docs/operate/observability)
