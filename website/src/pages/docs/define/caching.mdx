---
layout: ../../../layouts/DocsLayout.astro
title: Query Result Caching
description: Configure hypequery's cache layer, override per-query behavior, and push events to your own store
---

# Query Result Caching (Preview)

hypequery can cache `execute()` results at the builder level. It fingerprints the generated SQL + parameters, dedupes in-flight requests, and optionally serves stale responses while refreshing in the background. Use this page whenever you miss the original caching doc.

## Turn it on

Enable caching when you create the builder:

```typescript
import { createQueryBuilder, MemoryCacheProvider } from '@hypequery/clickhouse';

const db = createQueryBuilder({
  host: process.env.CLICKHOUSE_HOST!,
  cache: {
    mode: 'stale-while-revalidate',
    ttlMs: 2_000,
    staleTtlMs: 30_000,
    staleIfError: true,
    provider: new MemoryCacheProvider({ maxEntries: 1_000 })
  }
});
```

Override behaviour per query using `.cache()` or at execution time with `execute({ cache })`:

```typescript
const leaderboard = db
  .table('orders')
  .sum('total', 'revenue')
  .cache({ tags: ['orders'], ttlMs: 5_000 });

await leaderboard.execute({ cache: { mode: 'network-first' } });
```

Pass `cache: false` (or `.cache(false)`) to bypass the cache altogether.

## Modes + knobs

| Mode | Description |
| --- | --- |
| `cache-first` | Serve hot entries, otherwise fetch + store. |
| `network-first` | Always hit ClickHouse; fall back to stale data when `staleIfError` is enabled. |
| `stale-while-revalidate` | Serve stale-but-fresh-enough results immediately and trigger a background refresh. |
| `no-store` | Skip caching entirely. |

Other options:

- `ttlMs` + `staleTtlMs` – freshness + max staleness windows.
- `cacheTimeMs` – GC window for inactive entries.
- `dedupe` – disable in-flight request deduplication if you genuinely need double hits.
- `serialize` / `deserialize` – override JSON serialization (e.g., superjson, msgpack).
- `tags` – attach manual invalidation labels (automatically merged with table-derived tags).

## Observability + invalidation

Hook into the cache controller for stats and cache busting:

```typescript
await db.cache.invalidateKey('hq:v1:analytics:orders:abc123');
await db.cache.invalidateTags(['orders', 'dashboards']);
await db.cache.clear();

await db.cache.warm([
  () => leaderboard.execute(),
  () => db.table('users').count().cache({ tags: ['users'] }).execute(),
]);

const stats = db.cache.getStats();
console.log(stats.hitRate, stats.staleHits);
```

Every execution sends cache metadata to the logger (`cacheStatus`, `cacheMode`, `cacheAgeMs`). Combine this with `logger.configure({ onQueryLog })` for dashboards.

## BYO cache provider

Implement the `CacheProvider` interface to back the cache with Redis, Upstash, KV, etc.:

```typescript
import type { CacheEntry, CacheProvider } from '@hypequery/clickhouse';
import { Redis } from 'ioredis';

class RedisCacheProvider implements CacheProvider<string> {
  constructor(private readonly client = new Redis(process.env.REDIS_URL!)) {}

  async get(key: string) {
    const raw = await this.client.get(key);
    return raw ? (JSON.parse(raw) as CacheEntry) : null;
  }

  async set(key: string, entry: CacheEntry) {
    await this.client.set(key, JSON.stringify(entry), 'PX', entry.cacheTimeMs ?? entry.ttlMs);
  }

  async delete(key: string) {
    await this.client.del(key);
  }

  async deleteByTag(namespace: string, tag: string) {
    const tagKey = `hq:tag:${namespace}:${tag}`;
    const keys = await this.client.smembers(tagKey);
    if (keys.length) await this.client.del(...keys);
    await this.client.del(tagKey);
  }
}
```

Use the provider in your builder or via `.cache({ provider })`. If your store supports namespaces or tag eviction, implement `deleteByTag` / `clearNamespace` so `db.cache.invalidateTags()` can work without brute-force scans.

## Best practices

- **Start with SWR** for dashboards and read-heavy workloads; it gives instant responses with background refresh.
- **Tag everything** so mutations can invalidate related queries via `db.cache.invalidateTags([...])`.
- **Watch stats** (`db.cache.getStats()`) and log spikes in misses or stale hits.
- **Document overrides**—`cache: false` sprinkled throughout app code becomes technical debt quickly.

Caching is optional, but once you dial in TTLs + invalidation it dramatically reduces ClickHouse load while keeping APIs snappy.
