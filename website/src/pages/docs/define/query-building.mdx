---
layout: ../../../layouts/DocsLayout.astro
title: Query Building - hypequery
description: Learn how to build powerful queries with hypequery's fluent API
---

import Callout from '../../../components/Callout.astro';

# Query Building

hypequery ships with a fluent type-safe query builder exposed from the `@hypequery/clickhouse` package. This can be used in isolation, see the reference guide [here](/docs/reference/standalone-query-builder) or when you define queries inside the `defineServe` function.

This page shows the most common clauses: `select`, `where`, `join`, `groupBy`, `having`, `orderBy`, `limit`/`offset`, and `toSQL`.

```ts
import { initServe } from '@hypequery/serve';
import { z } from 'zod';
import { db } from './client';

const { define, queries, query } = initServe({
  context: () => ({ db }),
});

export const api = define({
  queries: queries({
    // examples below look like:
    // tripsQuery: query.describe('...').input(...).query(({ ctx }) => ctx.db ...),
  }),
});
```

## Selecting columns

```ts
activeUsers: {
  query: ({ ctx }) =>
    ctx.db.table('users').select([
      'id',
      'email AS user_email',
      ctx.db.rawAs('status', 'account_status'),
    ]),
}
```

- Write aliases inline (`'email AS user_email'`) or use helpers like `rawAs`, `selectExpr`, `toDateTime` when you’re building expressions.
- Use `select('*')` when you truly need every column:

  ```ts
  allUsers: {
    query: ({ ctx }) => ctx.db.table('users').select('*'),
  }
  ```

---

## Where conditions

`where` is the most flexible clause in the builder: pass column/operator/value triples, raw predicates, or predicate-builder callbacks, and chain them in any combination.

```ts
monthlyTrials: {
  inputSchema: z.object({ month: z.string() }),
  query: ({ ctx, input }) =>
    ctx.db
      .table('trials')
      .where('started_at', 'gte', `${input.month}-01`)
      .where('started_at', 'lt', `${input.month}-31`)
      .where('status', 'eq', 'active'),
}
```

**Type definitions**

```
where(column, operator, value): this
where(condition: WhereExpression): this
where(builder: (expr) => PredicateExpression): this

orWhere(column, operator, value): this
orWhere(builder: (expr) => PredicateExpression): this

whereGroup(callback: (builder) => void): this
orWhereGroup(callback: (builder) => void): this
```

- `column` – Valid base/joined column name.
- `operator` – `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `like`, `notLike`, `in`, `notIn`, `between`, etc.
- `value` – Value/array passed to the operator (strings, numbers, arrays, subqueries).
- `condition` – Prebuilt `WhereExpression` (useful when reusing predicates).
- `builder` – Receives the predicate helpers shown below.
- Every call returns the builder for chaining.

### Comparison cheat sheet:

| Operator | Description | Example |
| --- | --- | --- |
| `eq` / `neq` | Equal / not equal | `where('age', 'eq', 25)` |
| `gt` / `gte` | Greater than (or equal) | `where('age', 'gte', 18)` |
| `lt` / `lte` | Less than (or equal) | `where('price', 'lt', 100)` |
| `like` / `notLike` | Pattern matches | `where('email', 'like', '%@company.com')` |
| `in` / `notIn` | Array membership | `where('status', 'in', ['active', 'pending'])` |
| `between` | Inclusive range | `where('age', 'between', [18, 65])` |

### Function Predicates

  ```ts
  taggedProducts: {
    query: ({ ctx }) =>
      ctx.db
        .table('products')
        .where((expr) =>
          expr.and([
            expr.fn('hasAny', 'tags', ['launch', 'beta']),
            expr.fn('endsWith', 'status', expr.literal('active')),
          ])
        ),
  }
  ```

  The callback receives a `PredicateBuilder` with helpers like `expr.fn`, `expr.literal`, `expr.array`, `expr.raw`, `expr.and`, and `expr.or` so you can model ClickHouse functions safely.

  Builder helper summary:

  | Helper | Purpose |
  | --- | --- |
  | `expr.fn(name, ...args)` | Variadic function helper; strings become column refs, arrays become ClickHouse literals, primitives become parameters. |
  | `expr.col(column)` | Explicit column reference for edge cases. |
  | `expr.array(values)` | Build ClickHouse array literals explicitly when needed. |
  | `expr.literal(value)` / `expr.value(value)` | Force literal values so strings aren’t treated as column names. |
  | `expr.raw(sql)` | Inline raw SQL fragments when necessary. |
  | `expr.and([...])` / `expr.or([...])` | Combine multiple expressions without manual parentheses (or call `.orWhere(expr => …)` for top-level OR blocks). |

### Advanced IN Operators

The where method supports advanced IN operators for ClickHouse, including distributed/global, tuple, subquery, and table reference forms.

All IN operator variants are supported:

```ts
tupleJoin: {
  query: ({ ctx }) =>
    ctx.db
      .table('events')
      .where(['counter_id', 'user_id'], 'inTuple', [
        [34, 123],
        [101500, 456],
      ]),
}
```

| Operator | Description | Example |
| --- | --- | --- |
| `in` / `notIn` | Standard array membership | `where('status', 'in', ['active', 'pending'])` |
| `globalIn` / `globalNotIn` | GLOBAL IN for distributed tables | `where('user_id', 'globalIn', [1, 2, 3])` |
| `inSubquery` / `globalInSubquery` | Subquery string | `where('user_id', 'inSubquery', 'SELECT id FROM users')` |
| `inTable` / `globalInTable` | Table reference | `where('user_id', 'inTable', 'users')` |
| `inTuple` / `globalInTuple` | Multi-column tuple membership | `where(['c1','c2'], 'inTuple', [[1,2],[3,4]])` |

---

## Joins

<Callout>
    TypeScript only exposes columns from a joined table after you register the join. Call
    <code>leftJoin('users', ...)</code> before referencing <code>users.email</code> in <code>select</code>,
    <code>where</code>, etc., so those fields exist on the builder type.
</Callout>

```ts
ordersWithUsers: {
  query: ({ ctx }) =>
    ctx.db
      .table('orders')
      .leftJoin('users', 'orders.user_id', 'users.id')
      .select([
        'orders.id',
        'orders.total',
        'users.email AS customer_email',
      ]),
}
```

Available helpers: `innerJoin`, `leftJoin`, `rightJoin`, `fullJoin`.

---

## Group By

```ts
revenueByCountry: {
  query: ({ ctx }) =>
    ctx.db
      .table('orders')
      .select(['country'])
      .sum('total', 'total_revenue')
      .groupBy(['country']),
}
```

Call aggregation helpers (`sum`, `avg`, `count`, `distinctCount`, etc.) before `groupBy`.

---

## Order by

```ts
mostRecentSessions: {
  query: ({ ctx }) =>
    ctx.db
      .table('sessions')
      .select(['id', 'user_id', 'started_at'])
      .orderBy('started_at', 'DESC')
      .orderBy('id', 'ASC'),
}
```

- Signature: `orderBy(column, direction = 'ASC')`
- `column` accepts any base/joined column. `direction` is `'ASC'` or `'DESC'` (defaults to ascending).
- Chain multiple calls for secondary sorting.

---

## Limit & Offset

```ts
paginatedEvents: {
  inputSchema: z.object({ limit: z.number().default(50), offset: z.number().default(0) }),
  query: ({ ctx, input }) =>
    ctx.db
      .table('events')
      .select(['id', 'name'])
      .orderBy('occurred_at', 'DESC')
      .limit(input.limit)
      .offset(input.offset),
}
```

Both helpers validate non-negative numbers.

---

## toSQL

```ts
const preview = ctx.db
  .table('orders')
  .select(['user_id'])
  .sum('total', 'total_spent')
  .groupBy(['user_id']);

const sql = preview.toSQL();
// SELECT user_id, sum(total) AS total_spent FROM orders GROUP BY user_id
```

`toSQLWithParams()` returns `{ sql, params }` for parameterized output.

---

## Distinct

```ts
countries: {
  query: ({ ctx }) =>
    ctx.db.table('users').select(['country']).distinct(),
}
```

- Signature: `distinct(): this`
- Removes duplicate rows from the result set (ClickHouse `DISTINCT`).

---

## Time-based functions

```ts
timeBuckets: {
  query: ({ ctx }) =>
    ctx.db
      .table('events')
      .select([
        toDateTime('occurred_at', 'event_ts'),
        formatDateTime('occurred_at', 'Y-MM-dd HH:00', { alias: 'hour_bucket' }),
        toStartOfInterval('occurred_at', '1 hour', 'hour_start'),
        datePart('week', 'occurred_at', 'week_no'),
      ])
      .groupBy(['hour_bucket', 'hour_start', 'week_no'])
      .orderBy('hour_bucket', 'ASC'),
}
```

- `toDateTime(field, alias?)` converts values into ClickHouse `DateTime` objects.
- `formatDateTime(field, format, { timezone?, alias? })` formats timestamps with optional `timezone`.
- `toStartOfInterval(field, interval, alias?)` truncates to windows like `'15 minute'`, `'7 day'`.
- `datePart(part, field, alias?)` extracts `year`, `month`, `day`, etc.

### Grouping by time intervals

```ts
hourlySpend: {
  query: ({ ctx }) =>
    ctx.db
      .table('orders')
      .sum('total', 'total_spend')
      .groupByTimeInterval('created_at', '1 hour'),
}
```

- Built-in helpers: `groupByTimeInterval('timestamp', null, 'toStartOfMinute' | 'toStartOfHour' | 'toStartOfDay' | 'toStartOfWeek' | 'toStartOfMonth' | 'toStartOfQuarter' | 'toStartOfYear')`.
- Custom intervals: pass `'5 minute'`, `'2 hour'`, `'7 day'`, etc., as the second argument.

### Query settings

```ts
constrainedQuery: {
  query: ({ ctx }) =>
    ctx.db
      .table('large_table')
      .settings({
        max_execution_time: 60,
        max_threads: 4,
        max_memory_usage: '10000000000',
      })
      .select(['id'])
      .limit(1000),
}
```

- Settings map directly to ClickHouse query settings.
- TypeScript ensures date/time columns are used where required (`groupByTimeInterval` errors if you pass a numeric column).

---

## Common Table Expressions (CTEs)

```ts
const activeUsers = ctx.db
  .table('users')
  .select(['id', 'name'])
  .where('status', 'eq', 'active');

cteExample: {
  query: ({ ctx }) =>
    ctx.db
      .table('orders')
      .withCTE('active_users', activeUsers)
      .leftJoin('active_users', 'orders.user_id', 'active_users.id')
      .select(['orders.id', 'active_users.name']),
}
```

- Signature: `withCTE(alias, subquery | rawSql)`.
- Chain multiple CTEs:

```ts
complexReport: {
  query: ({ ctx }) => {
    const activeUsers = ctx.db
      .table('users')
      .select(['id', 'name'])
      .where('status', 'eq', 'active');

    const highValueOrders = ctx.db
      .table('orders')
      .select(['user_id', 'total'])
      .where('total', 'gte', 1000);

    return ctx.db
      .table('users')
      .withCTE('active_users', activeUsers)
      .withCTE('high_value_orders', highValueOrders)
      .leftJoin('high_value_orders', 'users.id', 'high_value_orders.user_id')
      .select(['users.name', 'high_value_orders.total']);
  },
}
```

Use raw SQL strings when needed: `.withCTE('recent', 'SELECT ...')`.
