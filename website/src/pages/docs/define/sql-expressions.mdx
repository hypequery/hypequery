---
layout: ../../../layouts/DocsLayout.astro
title: SQL Expressions
description: Use raw(), rawAs(), and selectExpr() to tap into ClickHouse features the fluent API doesn't cover
---

# SQL Expressions

hypequery's fluent API covers most daily workflows, but sometimes you need to drop down to SQL. The `raw`, `rawAs`, and `selectExpr` helpers let you inject hand-written expressions, keep aliases lined up with TypeScript, and still compose the rest of your query fluently. This page condenses the original raw/alias docs so you have one reference for every expression helper.

## `raw()` — inject SQL safely

`raw(expression, params?)` accepts any SQL fragment plus optional parameter bindings. hypequery will inline the expression verbatim and bind the parameters to keep things safe.

```typescript
import { raw } from '@hypequery/clickhouse';

const ageRange = db
  .table('users')
  .select(['id', 'name'])
  .where(raw('age BETWEEN ? AND ?', [18, 65]))
  .toSQL();
// SELECT id, name FROM users WHERE age BETWEEN 18 AND 65

const recent = db
  .table('orders')
  .where(raw('created_at >= subtractDays(now(), ?)', [7]))
  .toSQL();
// SELECT * FROM orders WHERE created_at >= subtractDays(now(), 7)

const bigNames = db
  .table('users')
  .where(raw('lengthUTF8(name) > 20'))
  .toSQL();
// SELECT * FROM users WHERE lengthUTF8(name) > 20
```

**Parameters**

- `expression: string` – any SQL fragment. Use `?` placeholders to bind variables.
- `params?: any[]` – optional array of values that will be bound to the placeholders.

Use `raw()` sparingly—TypeScript cannot validate the SQL fragment, so treat it as an escape hatch when the builder API falls short.

## `rawAs()` — give raw expressions an alias

`rawAs(expression, alias, params?)` behaves like `raw()` but adds an alias to the select list so you can reference it in `groupBy`, `orderBy`, `having`, and the returned row type.

```typescript
import { rawAs } from '@hypequery/clickhouse';

const agg = await db
  .table('orders')
  .select([
    'user_id',
    rawAs('SUM(total)', 'total_spent'),
    rawAs('COUNT(*)', 'order_count'),
    rawAs('AVG(total)', 'avg_order')
  ])
  .groupBy(['user_id'])
  .having(raw('total_spent > ?', [1_000]))
  .orderBy('total_spent', 'DESC')
  .execute();

const formattedUsers = await db
  .table('users')
  .select([
    'id',
    rawAs("concat(first_name, ' ', last_name)", 'full_name'),
    rawAs('toYear(created_at)', 'signup_year')
  ])
  .execute();
```

Common patterns:

| Pattern | Example |
| --- | --- |
| Aggregates with aliases | `rawAs('COUNT(DISTINCT customer_id)', 'unique_customers')` |
| Derived metrics | `rawAs('SUM(quantity * price)', 'total_revenue')` |
| JSON extraction | `rawAs("JSONExtractString(metadata, 'country')", 'country')` |

## `selectExpr()` — concise expressions + types

`selectExpr(expression, alias?)` is a lightweight wrapper that behaves like `raw` when no alias is supplied and like `rawAs` when you provide one. It is ideal when you are assembling projection lists entirely from expressions.

```typescript
import { selectExpr } from '@hypequery/clickhouse';

const weeklyTrips = await db
  .table('trips')
  .select([
    selectExpr('toStartOfWeek(pickup_datetime)', 'week'),
    selectExpr('count()', 'trip_count'),
    selectExpr('avg(total_amount)', 'avg_total')
  ])
  .groupBy('week')
  .orderBy('week', 'ASC')
  .execute();

const joinless = await db
  .table('users')
  .select([
    'id',
    selectExpr('JSONExtractString(metadata, \'plan\')', 'plan'),
    selectExpr('coalesce(last_active_at, created_at)') // no alias required
  ])
  .execute();
```

When you need parameterized expressions with placeholders, prefer `raw()` / `rawAs()` so you can pass the `params` array. For most computed columns or window functions, `selectExpr()` keeps the syntax tidy and automatically wires aliases back into the schema.

## ClickHouse helpers

hypequery ships typed wrappers for popular ClickHouse functions so you don't have to remember the SQL signature:

```typescript
import { 
  toDateTime,
  formatDateTime,
  toStartOfInterval,
  datePart
} from '@hypequery/clickhouse';

const query = builder
  .table('events')
  .select([
    'id',
    'event_type',
    toDateTime('timestamp', 'event_time'),            // toDateTime(timestamp) AS event_time
    formatDateTime('timestamp', 'Y-m-d', 'date'),     // formatDateTime(timestamp, 'Y-m-d') AS date
    toStartOfInterval('timestamp', '1 hour', 'hour')  // toStartOfInterval(...) AS hour
  ])
  .where('event_type', 'eq', 'purchase')
  .groupBy(['event_type', 'hour'])
  .toSQL();
```

## Type handling & best practices

When using SQL expressions, the resulting value will be typed as `any` in the return type. You can use TypeScript assertions if you need more specific typing:

```typescript
const result = await builder
  .table('events')
  .select([
    'id',
    rawAs('toDate(timestamp)', 'date')
  ])
  .execute();

// TypeScript doesn't know the type of 'date', so you can assert it:
const dates = result.map(row => row.date as Date);
```

```typescript
const result = await db
  .table('events')
  .select([
    rawAs('toDate(timestamp)', 'event_date')
  ])
  .execute();

type Row = (typeof result)[number] & { event_date: string };
const normalized = result.map((row) => ({
  ...row,
  event_date: new Date(row.event_date),
}));
```

Best practices:

- **Prefer builder helpers** — reach for `raw*` helpers only when a fluent method doesn't exist.
- **Parameterize user input** — always use `?` placeholders with the `params` array when incorporating external values.
- **Name expressions intentionally** — alias computed columns so downstream clauses and the result type can reference them reliably.

## See also

- [Query Building](/docs/define/query-building)
- [Advanced Features](/docs/define/advanced-features)
- [Schema Modeling](/docs/define/schema-modeling)
