---
layout: ../../../layouts/DocsLayout.astro
title: Architecture tour
description: See how hypequery components fit together from ClickHouse to runtime delivery
---

# Architecture Tour

This page explains how hypequery is structured and how analytics flow from definition to execution.

hypequery is intentionally layered. Each layer has a single responsibility, and higher layers depend on lower ones — never the other way around.

## The mental model

At a high level, hypequery works like this:

1. You define your metrics and queries in code
2. Those definitions are compiled into an executable form
3. You choose how and where to run them
4. Delivery mechanisms (HTTP, SDKs, agents) sit at the edge

**The core idea:**
analytics logic is defined once, and execution is a deployment choice.

## Core layers

### 1. Query & metric definitions

On top of your ClickHouse schema, you define queries and metrics.

**Each definition is:**

- Named
- Typed (inputs and outputs)
- Optional metadata (description, tags, ownership)

**These definitions are pure logic:**

- No transport assumptions
- No runtime assumptions
- No UI coupling

This is the semantic layer — expressed in code.

### 2. Execution engine

The execution layer is responsible for:

- Turning definitions into SQL
- Running queries against ClickHouse
- Returning typed results

**This is where:**

- Our query builder
- Database adapters
- Caching (if enabled)

live.

**Execution can happen:**

- In-process (default)
- Repeatedly (cron, jobs, agents)
- With or without HTTP

### 3. Runtime targets (delivery)

Delivery is optional and interchangeable.

**A metric can be exposed to:**

- Application code (`api.run`)
- HTTP endpoints
- Generated SDKs
- AI agents and automation

These are adapters, not core logic.

**Changing how a metric is delivered does not change:**

- Its definition
- Its SQL
- Its semantics

## Data flow

A typical flow looks like:

1. **Schema** defines the shape of your data
2. **Metrics** reference schemas
3. **Execution engine** compiles and runs queries
4. **Results** are returned to the caller
5. **(Optional)** Results pass through HTTP or SDK layers

Every step is explicit and inspectable.

## Embedded-first by design

hypequery treats embedded execution as the default.

**This means:**

- No mandatory server
- No required HTTP setup
- No runtime split between "data" and "app"

**HTTP exists for:**

- Frontend consumption
- External access
- Public or shared metrics

But it is never required for correctness.

## Optional infrastructure

Features like:

- HTTP servers
- OpenAPI generation
- SDK clients
- Caching
- Observability

are opt-in layers.

They depend on core definitions — never the reverse.

**This keeps hypequery:**

- Composable
- Testable
- Easy to reason about
- Hard to misuse

## What hypequery does not do

Understanding the boundaries is part of the architecture.

**hypequery does not:**

- Host your data
- Provide a dashboard UI
- Infer business logic automatically
- Replace your database

It provides a clean, typed layer between your data and everything that consumes it.

## Why this architecture matters

This design makes it possible to:

- Share metrics across teams without drift
- Let humans and agents use the same analytics safely
- Change delivery mechanisms without rewriting logic
- Keep ownership and versioning explicit

The result is analytics that behaves like software — not config.

---

**Next**: Jump to the [Quickstart](/docs/getting-started/quickstart) to build your first query.
