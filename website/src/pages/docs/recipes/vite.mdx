---
layout: ../../../layouts/DocsLayout.astro
title: Vite + hypequery
description: Run hypequery as a standalone API next to a Vite/React frontend.
---

# Vite + hypequery

Expose analytics through a dedicated hypequery server and call it from your Vite frontend via a proxy.

## Use case

You want separate frontend/backend processes so you can:
- Keep the analytics API in its own Node process (or container)
- Proxy `/api/*` requests during development to avoid CORS
- Deploy the API independently (Render, Railway, Fly.io, etc.)

## Prerequisites

- Node.js 18+
- Vite + React project (`npm create vite@latest my-app -- --template react`)
- ClickHouse credentials (`CLICKHOUSE_URL`, `CLICKHOUSE_USER`, `CLICKHOUSE_PASSWORD`)
- Packages: `@hypequery/serve`, `@hypequery/clickhouse`, `zod`, `@tanstack/react-query`

```bash
npm install @hypequery/serve @hypequery/clickhouse zod
npm install @tanstack/react-query
```

## 1. Define the API (standalone Node entry)

`api/queries.ts`

```typescript
import 'dotenv/config';
import { initServe } from '@hypequery/serve';
import { createQueryBuilder } from '@hypequery/clickhouse';
import { z } from 'zod';

const db = createQueryBuilder({
  url: process.env.CLICKHOUSE_URL!,
  username: process.env.CLICKHOUSE_USER!,
  password: process.env.CLICKHOUSE_PASSWORD,
});

const { define, queries, query } = initServe({
  context: () => ({ db }),
});

export const api = define({
  queries: queries({
    hello: query
      .describe('Simple greeting')
      .output(z.object({ message: z.string(), at: z.string() }))
      .query(async () => ({
        message: 'Hello from hypequery! ',
        at: new Date().toISOString(),
      })),

    weeklyRevenue: query
      .describe('Revenue by ISO week')
      .input(z.object({ startDate: z.string(), endDate: z.string() }))
      .output(z.array(z.object({ week: z.string(), revenue: z.number() })))
      .query(async ({ ctx, input }) =>
        ctx.db
          .table('orders')
          .where('created_at', 'gte', input.startDate)
          .where('created_at', 'lte', input.endDate)
          .groupBy(['toISOWeek(created_at) AS week'])
          .sum('amount', 'revenue')
          .orderBy('week', 'ASC')
          .execute()
      ),
  }),
});

api
  .route('/hello', api.queries.hello, { method: 'GET' })
  .route('/weeklyRevenue', api.queries.weeklyRevenue, { method: 'POST' });
```

### Run the API locally

```bash
npx hypequery dev api/queries.ts --port 4000
# Docs â†’ http://localhost:4000/docs
```

## 2. Proxy `/api/*` requests in Vite

`vite.config.ts`

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
});
```

During development `fetch('/api/hello')` hits the hypequery server without CORS hassles.

## 3. Build a tiny client helper

`src/lib/hypequery.ts`

```typescript
export async function callMetric<T>(path: string, options?: RequestInit): Promise<T> {
  const res = await fetch(`/api${path}`, {
    headers: { 'content-type': 'application/json', ...(options?.headers ?? {}) },
    ...options,
  });
  if (!res.ok) throw new Error(`API ${path} failed: ${res.status}`);
  return res.json();
}
```

## 4. Use metrics in React components

`src/App.tsx`

```tsx
import { useState } from 'react';
import { callMetric } from './lib/hypequery';

export default function App() {
  const [hello, setHello] = useState<any>(null);
  const [revenue, setRevenue] = useState<any>(null);

  return (
    <main>
      <button onClick={() => callMetric('/hello').then(setHello)}>Greet</button>
      <button
        onClick={() =>
          callMetric('/weeklyRevenue', {
            method: 'POST',
            body: JSON.stringify({ startDate: '2024-01-01', endDate: '2024-01-31' }),
          }).then(setRevenue)
        }
      >
        Load Revenue
      </button>

      {hello && <pre>{JSON.stringify(hello, null, 2)}</pre>}
      {revenue && <pre>{JSON.stringify(revenue, null, 2)}</pre>}
    </main>
  );
}
```

## 5. Develop both servers together

`package.json`

```json
{
  "scripts": {
    "dev": "vite",
    "api": "hypequery dev api/queries.ts --port 4000",
    "dev:all": "concurrently \"npm run dev\" \"npm run api\""
  }
}
```

Run `npm run dev:all` to start Vite (port 5173) and hypequery (port 4000) simultaneously.

## Deployment tips

- Ship the hypequery API as its own service (`npx hypequery serve api/queries.ts --port 4000` or Docker).
- Point `baseUrl` to the hosted API (e.g., `https://analytics.myapp.com`).
- In production builds, update `callMetric` to hit the real URL instead of the Vite proxy.

## Next steps

- Protect the API with `auth: async () => ({ userId, roles, tenantId })` and `tenant: { extract }`
- Use `@hypequery/react` to generate React Query hooks instead of `callMetric`
- Add caching to the ClickHouse builder (`cache: { mode: 'stale-while-revalidate', ttlMs: ... }`)
