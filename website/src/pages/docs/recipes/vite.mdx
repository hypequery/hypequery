---
layout: ../../../layouts/DocsLayout.astro
title: Vite + hypequery
description: Run hypequery as a standalone API next to a Vite/React frontend.
---

# Vite + hypequery

Expose analytics through a dedicated hypequery server and call it from your Vite frontend via a proxy.

## Use case

You want separate frontend/backend processes so you can:
- Keep the analytics API in its own Node process (or container)
- Proxy `/api/*` requests during development to avoid CORS
- Deploy the API independently (Render, Railway, Fly.io, etc.)

## Prerequisites

- Node.js 18+
- Vite + React project (`npm create vite@latest my-app -- --template react`)
- ClickHouse credentials (`CLICKHOUSE_URL`, `CLICKHOUSE_USER`, `CLICKHOUSE_PASSWORD`)
- Packages: `@hypequery/serve`, `@hypequery/clickhouse`, `zod`, `@tanstack/react-query`
- Dev packages: `@hypequery/cli`, `concurrently`

```bash
npm install @hypequery/serve @hypequery/clickhouse zod @tanstack/react-query
npm install --save-dev @hypequery/cli concurrently
```

## 1. Define the API (standalone Node entry)

`api/queries.ts`

```typescript
import 'dotenv/config';
import { initServe } from '@hypequery/serve';
import { createQueryBuilder } from '@hypequery/clickhouse';
import { z } from 'zod';

const clickhouseHost = process.env.CLICKHOUSE_URL || process.env.CLICKHOUSE_HOST;
const clickhouseUsername = process.env.CLICKHOUSE_USER || process.env.CLICKHOUSE_USERNAME;
const clickhouseDatabase = process.env.CLICKHOUSE_DATABASE;

const db = createQueryBuilder({
  host: clickhouseHost!,
  username: clickhouseUsername!,
  password: process.env.CLICKHOUSE_PASSWORD,
  database: clickhouseDatabase,
});

const { define, queries, query } = initServe({
  context: () => ({ db }),
});

export const api = define({
  queries: queries({
    hello: query
      .describe('Simple greeting')
      .output(z.object({ message: z.string(), at: z.string() }))
      .query(async () => ({
        message: 'Hello from hypequery! ',
        at: new Date().toISOString(),
      })),

    weeklyRevenue: query
      .describe('Revenue by ISO week')
      .input(z.object({ startDate: z.string(), endDate: z.string() }))
      .output(z.array(z.object({ week: z.string(), revenue: z.number() })))
      .query(async ({ ctx, input }) =>
        ctx.db
          .table('orders')
          .where('created_at', 'gte', input.startDate)
          .where('created_at', 'lte', input.endDate)
          .groupBy(['toISOWeek(created_at) AS week'])
          .sum('amount', 'revenue')
          .orderBy('week', 'ASC')
          .execute()
      ),
  }),
});

api
  .route('/hello', api.queries.hello, { method: 'GET' })
  .route('/weeklyRevenue', api.queries.weeklyRevenue, { method: 'POST' });
```

### Run the API locally

```bash
npm run api
# or manually: npx hypequery dev api/queries.ts --port 4000
# Docs â†’ http://localhost:4000/docs
```

## 2. Proxy `/api/*` requests in Vite

`vite.config.ts`

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
});
```

During development `fetch('/api/hello')` hits the hypequery server without CORS hassles.

## 3. Build a tiny client helper

`src/lib/hypequery.ts`

```typescript
export async function callMetric<T>(path: string, options?: RequestInit): Promise<T> {
  const res = await fetch(`/api${path}`, {
    headers: { 'content-type': 'application/json', ...(options?.headers ?? {}) },
    ...options,
  });

  if (!res.ok) {
    throw new Error(`API ${path} failed: ${res.status}`);
  }

  return res.json();
}
```

## 4. Use metrics in React components

`src/App.tsx`

```tsx
import { useState } from 'react';
import { callMetric } from './lib/hypequery';

type LoadState = 'idle' | 'loading' | 'error';

export default function App() {
  const [hello, setHello] = useState<any>(null);
  const [helloState, setHelloState] = useState<LoadState>('idle');
  const [helloError, setHelloError] = useState<string | null>(null);

  const [revenue, setRevenue] = useState<any>(null);
  const [revenueState, setRevenueState] = useState<LoadState>('idle');
  const [revenueError, setRevenueError] = useState<string | null>(null);

  async function fetchHello() {
    setHelloState('loading');
    setHelloError(null);
    try {
      const data = await callMetric('/hello');
      setHello(data);
      setHelloState('idle');
    } catch (err) {
      setHelloError((err as Error).message);
      setHelloState('error');
    }
  }

  async function fetchRevenue() {
    setRevenueState('loading');
    setRevenueError(null);
    try {
      const data = await callMetric('/weeklyRevenue', {
        method: 'POST',
        body: JSON.stringify({ startDate: '2024-01-01', endDate: '2024-01-31' }),
      });
      setRevenue(data);
      setRevenueState('idle');
    } catch (err) {
      setRevenueError((err as Error).message);
      setRevenueState('error');
    }
  }

  return (
    <main>
      <button onClick={fetchHello} disabled={helloState === 'loading'}>
        {helloState === 'loading' ? 'Loading...' : 'Greet'}
      </button>
      <button onClick={fetchRevenue} disabled={revenueState === 'loading'}>
        {revenueState === 'loading' ? 'Loading...' : 'Load Revenue'}
      </button>

      {helloError && <p role="alert">{helloError}</p>}
      {hello && <pre>{JSON.stringify(hello, null, 2)}</pre>}

      {revenueError && <p role="alert">{revenueError}</p>}
      {revenue && <pre>{JSON.stringify(revenue, null, 2)}</pre>}
    </main>
  );
}
```

## 5. Develop both servers together

`package.json`

```json
{
  "scripts": {
    "dev": "vite",
    "api": "hypequery dev api/queries.ts --port 4000",
    "dev:all": "concurrently \"npm run dev\" \"npm run api\""
  },
  "devDependencies": {
    "@hypequery/cli": "latest",
    "concurrently": "latest"
  }
}
```

Run `npm run dev:all` to start Vite (port 5173) and hypequery (port 4000) simultaneously.

## Deployment tips

- Ship the hypequery API as its own service (`npx hypequery serve api/queries.ts --port 4000` or Docker).
- Point `baseUrl` to the hosted API (e.g., `https://analytics.myapp.com`).
- In production builds, update `callMetric` to hit the real URL instead of the Vite proxy.

## Next steps

- Protect the API with `auth: async () => ({ userId, roles, tenantId })` and `tenant: { extract }`
- Use `@hypequery/react` to generate React Query hooks instead of `callMetric`
- Add caching to the ClickHouse builder (`cache: { mode: 'stale-while-revalidate', ttlMs: ... }`)
