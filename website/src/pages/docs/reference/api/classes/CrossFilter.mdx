---
layout: ../../../../../layouts/DocsLayout.astro
title: Class - CrossFilter\<Schema, TableName\>
description: API documentation for hypequery ClickHouse library
---

CrossFilter

# Class: CrossFilter\<Schema, TableName\>

A type-safe filter builder supporting both simple conditions and complex nested groups.

## Type Parameters

### Schema

`Schema` *extends* `object` = `any`

The full database schema type

### TableName

`TableName` *extends* keyof `Schema` = `Extract`\<keyof `Schema`, `string`\>

The specific table being filtered

## Constructors

### Constructor

**new CrossFilter**\<`Schema`, `TableName`\>(`schema`?, `tableName`?): `CrossFilter`\<`Schema`, `TableName`\>

Constructors support three modes:

1. `new CrossFilter()` – schema-agnostic filters for quick, ad-hoc usage.
2. `new CrossFilter(schema)` – validates columns against the provided schema across every table.
3. `new CrossFilter(schema, 'table_name')` – validates columns against a specific table, enabling the best editor autocomplete when reused across queries.

#### Parameters

##### schema?

`Schema`

##### tableName?

`TableName`

#### Returns

`CrossFilter`\<`Schema`, `TableName`\>

```ts
import { CrossFilter } from '@hypequery/clickhouse';

const schema = {
  trips: {
    pickup_datetime: 'DateTime',
    total_amount: 'Float32',
    // ...rest of your columns
  }
} as const;

const typedFilter = new CrossFilter(schema, 'trips')
  .add({ column: 'pickup_datetime', operator: 'gte', value: '2024-01-01' });
```

## Methods

### add()

**add**\<`ColumnName`, `Op`\>(`condition`): `this`

Adds a single filter condition to the root group with an implicit AND conjunction.
Performs type-safe validation if a schema is provided.

#### Type Parameters

##### ColumnName

`ColumnName` *extends* `string`

##### Op

`Op` *extends* keyof `OperatorValueMap`\<`any`\>

#### Parameters

##### condition

`FilterConditionInput`\<`OperatorValueMap`\<`InferClickHouseType`\<`Schema`\[`TableName`\]\[`ColumnName`\]\>\>\[`Op`\], `Schema`, `Schema`\[`TableName`\]\>

#### Returns

`this`

### addGroup()

**addGroup**(`groupConditions`, `operator`): `this`

Adds a nested group of filter conditions to the root group using the specified logical operator.

#### Parameters

##### groupConditions

(`FilterGroup`\<`Schema`, `Schema`\[`TableName`\]\> \| `FilterConditionInput`\<`any`, `Schema`, `Schema`\[`TableName`\]\>)[]

Array of filter conditions or nested groups to be grouped together.

##### operator

Logical operator ('AND' or 'OR') to combine the conditions in the group.

`"AND"` | `"OR"`

#### Returns

`this`

### addMultiple()

**addMultiple**(`conditions`): `this`

Adds multiple filter conditions to the root group.

#### Parameters

##### conditions

`FilterConditionInput`\<`any`, `Schema`, `Schema`\[`TableName`\]\>[]

#### Returns

`this`

### getConditions()

**getConditions**(): `FilterGroup`\<`Schema`, `Schema`\[`TableName`\]\>

Returns the current filter tree representing all conditions and groups.

#### Returns

`FilterGroup`\<`Schema`, `Schema`\[`TableName`\]\>

### topN()

**topN**\<`K`\>(`valueColumn`, `n`, `orderBy`): `this`

Creates a filter for top N records by a value column

#### Type Parameters

##### K

`K` *extends* `string` \| `number` \| `symbol`

#### Parameters

##### valueColumn

`K`

The column to filter and order by

##### n

`number`

Number of records to return

##### orderBy

Sort direction, defaults to 'desc'

`"desc"` | `"asc"`

#### Returns

`this`
