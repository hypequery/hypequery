---
layout: ../../../layouts/DocsLayout.astro
title: Authentication
description: Secure hypequery endpoints with AuthStrategy functions, middleware, and runtime context
---

<div class="prose">

# Authentication

`@hypequery/serve` keeps authentication explicit: you provide `AuthStrategy` functions that accept the incoming request (or embedded call) and return your auth context. This page shows how to register strategies globally, override them per-endpoint, and propagate auth data through middleware or embedded calls.

## Core concepts

- **Auth strategies** run before middleware/handlers. They receive `{ request, endpoint }` and return an `AuthContext` object or `null`.
- **Global vs per-endpoint** – pass `auth` in `defineServe` to enforce auth across every query. Individual queries can provide their own `auth` to override or disable auth.
- **Auth context** is injected into `ctx.auth` and forwarded to tenant helpers, middlewares, and hooks.
- **Failures** – returning `null` triggers an `UNAUTHORIZED` error and fires `onAuthFailure` hooks. You can inspect `event.reason` to log missing vs invalid credentials.

## Basic usage

```ts
import { defineServe } from '@hypequery/serve';
import { z } from 'zod';

const apiKeyStrategy = async ({ request }) => {
  const key = request.headers['x-api-key'];
  if (!key || key !== process.env.HQ_API_KEY) {
    return null;
  }
  return { userId: 'service:dashboard', roles: ['internal'] };
};

export const api = defineServe({
  auth: apiKeyStrategy,
  queries: {
    revenue: {
      inputSchema: z.object({ range: z.string() }),
      query: ({ ctx, input }) => ctx.db.table('revenue').where('range', 'eq', input.range).select('*'),
    },
  },
});
```

Every HTTP request must include `x-api-key`; otherwise, the runtime returns `401 UNAUTHORIZED`. Embedded calls that skip the HTTP layer can still pass auth context manually (see below).

## Multiple strategies

Need to support API keys and bearer tokens simultaneously? Provide an array:

```ts
const bearerStrategy = async ({ request }) => {
  const header = request.headers.authorization;
  if (!header?.startsWith('Bearer ')) return null;
  const token = header.slice(7);
  const payload = await verifyJwt(token);
  return { userId: payload.sub, scopes: payload.scopes };
};

export const api = defineServe({
  auth: [apiKeyStrategy, bearerStrategy],
  queries: { /* ... */ },
});
```

Strategies run sequentially until one returns an auth context. If all return `null`, the request is rejected.

## Per-endpoint overrides

Some endpoints might need different auth rules (or none at all). Set `auth` inside the query definition:

```ts
queries: {
  healthcheck: {
    query: async () => ({ ok: true }),
    auth: null, // public endpoint
  },
  adminOnly: {
    auth: async ({ request }) => {
      const token = request.headers['x-admin-token'];
      return token === process.env.ADMIN_TOKEN ? { roles: ['admin'] } : null;
    },
    query: async ({ ctx }) => ctx.db.table('secrets').select('*'),
  },
}
```

When `auth: null`, the endpoint bypasses global strategies entirely.

## Auth guards

The builder API exposes declarative guards that control **who** can access each endpoint. These are checked after authentication succeeds, so the distinction is: authentication proves identity, guards enforce authorization.

### `.requireAuth()`

Explicitly mark an endpoint as requiring authentication. When no auth context is present, the request is rejected with `401 UNAUTHORIZED`:

```ts
const { define, query } = initServe({ context: () => ({ db }) });

const api = define({
  queries: {
    metrics: query
      .requireAuth()
      .query(async ({ ctx }) => ctx.db.table('metrics').select('*')),
  },
});
```

### `.requireRole()`

Require the user to have at least one of the listed roles. Uses OR semantics—any matching role grants access. Returns `403 FORBIDDEN` with details when no role matches:

```ts
const api = define({
  queries: {
    adminDashboard: query
      .requireRole('admin', 'super-admin')
      .query(async ({ ctx }) => ctx.db.table('admin_metrics').select('*')),

    editorView: query
      .requireRole('editor')
      .query(async ({ ctx }) => ctx.db.table('content_metrics').select('*')),
  },
});
```

Roles are checked against `ctx.auth.roles`. Your auth strategy must populate this field:

```ts
const authStrategy = async ({ request }) => {
  const token = request.headers.authorization?.slice(7);
  const payload = await verifyJwt(token);
  return {
    userId: payload.sub,
    roles: payload.roles,   // e.g. ['admin', 'viewer']
    scopes: payload.scopes, // e.g. ['read:metrics']
  };
};
```

### `.requireScope()`

Require the user to have **all** listed scopes. Uses AND semantics—every scope must be present. Returns `403 FORBIDDEN` when any scope is missing:

```ts
const api = define({
  queries: {
    sensitiveExport: query
      .requireScope('read:metrics', 'export:data')
      .query(async ({ ctx }) => ctx.db.table('exports').select('*')),
  },
});
```

Scopes are checked against `ctx.auth.scopes`. Combine with `.requireRole()` when you need both:

```ts
adminExport: query
  .requireRole('admin')
  .requireScope('export:data')
  .query(async ({ ctx }) => { /* ... */ }),
```

### `.public()`

Explicitly opt an endpoint out of authentication, even when global auth strategies are configured. The endpoint still _attempts_ auth (so `ctx.auth` is populated if credentials happen to be present) but never rejects:

```ts
const api = define({
  queries: {
    healthcheck: query
      .public()
      .query(async () => ({ status: 'ok' })),

    protectedMetric: query
      .requireAuth()
      .query(async ({ ctx }) => { /* ... */ }),
  },
});

api.useAuth(myGlobalStrategy); // healthcheck still accessible without credentials
```

### Error responses

Guards return structured errors that clients can branch on:

```json
{
  "error": {
    "type": "FORBIDDEN",
    "message": "Missing required role",
    "details": {
      "reason": "missing_role",
      "required": ["admin"],
      "actual": ["viewer"],
      "endpoint": "/admin-dashboard"
    }
  }
}
```

| Guard | HTTP status | Error type | Semantics |
| --- | --- | --- | --- |
| `.requireAuth()` | `401` | `UNAUTHORIZED` | No credentials |
| `.requireRole()` | `403` | `FORBIDDEN` | Wrong role (OR) |
| `.requireScope()` | `403` | `FORBIDDEN` | Missing scope (AND) |

### Middleware helpers

If you prefer to apply guards via `.use()` instead of the builder chain (e.g. shared middleware across queries), use the exported helpers:

```ts
import {
  requireAuthMiddleware,
  requireRoleMiddleware,
  requireScopeMiddleware,
} from '@hypequery/serve';

// Global: require auth on all endpoints
api.use(requireAuthMiddleware());

// Per-query: require admin role
adminQuery: {
  middlewares: [requireRoleMiddleware('admin')],
  query: async ({ ctx }) => { /* ... */ },
}
```

These throw errors with `status` and `type` properties that the pipeline maps to the correct HTTP responses.

### `onAuthorizationFailure` hook

Track authorization failures separately from authentication failures:

```ts
const api = defineServe({
  hooks: {
    onAuthFailure: (event) => {
      // 401 - no credentials or invalid credentials
      logger.warn('auth_failure', { reason: event.reason, path: event.metadata.path });
    },
    onAuthorizationFailure: (event) => {
      // 403 - authenticated but wrong role/scope
      logger.warn('authz_failure', {
        reason: event.reason,
        required: event.required,
        actual: event.actual,
        userId: event.auth?.userId,
        path: event.metadata.path,
      });
    },
  },
  queries: { /* ... */ },
});
```

## Accessing auth in middleware/handlers

`ctx.auth` contains whichever object your strategy returned:

```ts
const logUserMiddleware = async (ctx, next) => {
  console.log('request', ctx.metadata.path, 'user', ctx.auth?.userId ?? 'anonymous');
  return next();
};

export const api = defineServe({
  middlewares: [logUserMiddleware],
  /* ... */
});
```

You can enrich the context by returning additional fields from the strategy (roles, tenant IDs, plan tier, etc.).

## Embedded execution

When calling `api.run` directly (cron jobs, SSR handlers), pass a synthetic request so your strategies still run:

```ts
await api.run('revenue', {
  request: {
    method: 'POST',
    path: '/revenue',
    headers: { 'x-api-key': process.env.HQ_API_KEY },
    query: {},
  },
});
```

If you already trust the caller (e.g., an internal job), you can skip strategies by calling the underlying query manually or providing a custom `context` with `auth`. Just be explicit so you don’t accidentally bypass tenant enforcement.

## Troubleshooting

- **Missing headers** – ensure your framework forwards headers to the dev server. For example, when proxying through Next.js, copy `Authorization`/`X-API-Key` into the request.
- **Edge runtimes** – use `createFetchHandler` or `createVercelEdgeHandler` so headers/requests stay compatible with the strategies.
- **Logging failures** – implement `hooks.onAuthFailure` to capture repeated failures and alert your team.

With these patterns you can safely protect hypequery endpoints without tying yourself to a specific auth provider. Strategies are just functions—swap tokens, cookies, mTLS metadata, or anything your stack supports.

</div>
