---
layout: ../../../layouts/DocsLayout.astro
title: Custom metadata
description: Annotate queries with custom fields for governance, monitoring, and AI agents
---

<div class="prose">

# Custom metadata

Enrich your HypeQuery endpoints with custom metadata fields for governance, ownership tracking, SLA documentation, cost estimation, and AI agent integration.

## Overview

Custom metadata allows you to attach arbitrary key-value pairs to your queries that flow through to the API description. This enables:

- **Team ownership** - Track which team owns each endpoint
- **SLA documentation** - Document performance requirements
- **Cost tracking** - Estimate query execution costs
- **AI agent context** - Provide richer information for automation
- **Internal tooling** - Power dashboards, monitoring, and governance

## Basic usage

Add a `custom` field to any query configuration:

```typescript
import { defineServe } from '@hypequery/serve';

const api = defineServe({
  queries: {
    weeklyRevenue: {
      query: async () => {
        return db.table('transactions')
          .where('created_at', '>=', startOfWeek())
          .sum('amount');
      },
      custom: {
        owner: 'data-team',
        sla: '100ms',
        costEstimate: 'low',
        criticality: 'high',
      },
    },
  },
});

api.route('/metrics/weekly-revenue', api.queries.weeklyRevenue);
```

## Accessing metadata

Custom metadata is available through the `describe()` method:

```typescript
const description = api.describe();

description.queries.forEach((query) => {
  console.log({
    key: query.key,
    path: query.path,
    owner: query.custom?.owner,
    sla: query.custom?.sla,
    costEstimate: query.custom?.costEstimate,
  });
});

// Output:
// {
//   key: 'weeklyRevenue',
//   path: '/metrics/weekly-revenue',
//   owner: 'data-team',
//   sla: '100ms',
//   costEstimate: 'low'
// }
```

## Common use cases

### 1. Team ownership & contacts

```typescript
queries: {
  userAnalytics: {
    query: async ({ input }) => { /* ... */ },
    custom: {
      owner: 'analytics-team',
      contact: 'analytics@company.com',
      slackChannel: '#analytics-support',
      oncall: 'https://pagerduty.com/analytics',
    },
  },
}
```

### 2. Performance SLAs

```typescript
queries: {
  dashboardMetrics: {
    query: async ({ input }) => { /* ... */ },
    custom: {
      sla: '200ms',
      p99Target: '500ms',
      cacheable: true,
      cacheStrategy: 'stale-while-revalidate',
    },
  },
}
```

### 3. Cost estimation

```typescript
queries: {
  heavyAnalytics: {
    query: async ({ input }) => { /* ... */ },
    custom: {
      costEstimate: 'high',
      estimatedRows: '10M+',
      queryComplexity: 'complex',
      requiresOptimization: true,
    },
  },
}
```

### 4. Business criticality

```typescript
queries: {
  paymentProcessing: {
    query: async ({ input }) => { /* ... */ },
    custom: {
      criticality: 'critical',
      businessImpact: 'revenue',
      compliance: ['PCI-DSS', 'SOC2'],
      dataClassification: 'confidential',
    },
  },
}
```

### 5. AI agent context

```typescript
queries: {
  customerLookup: {
    query: async ({ input }) => { /* ... */ },
    custom: {
      aiDescription: 'Retrieves customer profile including contact info and purchase history',
      exampleUse: 'When user asks "what did customer john@example.com purchase?"',
      requiredParams: ['email or customerId'],
      rateLimit: '100/minute',
    },
  },
}
```

## TypeScript support

For type-safe custom metadata, extend the `ServeQueryConfig` type:

```typescript
import { defineServe, ServeQueryConfig } from '@hypequery/serve';

interface MyCustomMetadata {
  owner: string;
  team: string;
  sla: string;
  criticality: 'low' | 'medium' | 'high' | 'critical';
  costEstimate: 'low' | 'medium' | 'high';
}

const api = defineServe({
  queries: {
    revenue: {
      query: async () => { /* ... */ },
      custom: {
        owner: 'Jane Doe',
        team: 'data-engineering',
        sla: '100ms',
        criticality: 'high',
        costEstimate: 'low',
      } satisfies MyCustomMetadata,
    },
  },
});
```

## Integration with tooling

### Governance dashboard

Build an internal dashboard that displays endpoint ownership:

```typescript
const endpoints = api.describe().queries;

const byOwner = endpoints.reduce((acc, query) => {
  const owner = query.custom?.owner || 'unassigned';
  acc[owner] = acc[owner] || [];
  acc[owner].push({
    path: query.path,
    criticality: query.custom?.criticality,
    sla: query.custom?.sla,
  });
  return acc;
}, {} as Record<string, any[]>);

console.log('Endpoints by owner:', byOwner);
```

### SLA monitoring

Alert when queries exceed their documented SLA:

```typescript
import { defineServe } from '@hypequery/serve';

const api = defineServe({
  hooks: {
    onRequestEnd: async (event) => {
      const sla = event.metadata.custom?.sla;
      if (!sla) return;

      const targetMs = parseInt(sla); // e.g., "100ms" -> 100
      if (event.durationMs > targetMs) {
        await alertSlaBreach({
          query: event.queryKey,
          target: targetMs,
          actual: event.durationMs,
          severity: event.metadata.custom?.criticality || 'medium',
        });
      }
    },
  },
  queries: {
    dashboard: {
      query: async () => { /* ... */ },
      custom: {
        sla: '200ms',
        criticality: 'high',
      },
    },
  },
});
```

### Cost tracking

Track estimated costs by endpoint:

```typescript
const description = api.describe();

const highCostQueries = description.queries
  .filter(q => q.custom?.costEstimate === 'high')
  .map(q => ({
    path: q.path,
    owner: q.custom?.owner,
    estimatedRows: q.custom?.estimatedRows,
  }));

console.log('High-cost queries requiring optimization:', highCostQueries);
```

### AI agent discovery

Expose metadata to AI agents via MCP (Model Context Protocol):

```typescript
// AI agent can inspect available tools
const tools = api.describe().queries.map(query => ({
  name: query.key,
  description: query.summary,
  aiContext: query.custom?.aiDescription,
  exampleUse: query.custom?.exampleUse,
  parameters: query.inputSchema,
  output: query.outputSchema,
}));

// AI can now understand:
// - What each tool does (aiDescription)
// - When to use it (exampleUse)
// - What parameters it needs (inputSchema)
// - What it returns (outputSchema)
```

## Real-world example

Here's a production setup with comprehensive metadata:

```typescript
import { defineServe } from '@hypequery/serve';
import { z } from 'zod';

const api = defineServe({
  queries: {
    // Customer-facing revenue dashboard
    revenueMetrics: {
      query: async ({ input }) => {
        return db.table('transactions')
          .where('date', '>=', input.startDate)
          .where('date', '<=', input.endDate)
          .groupBy('date')
          .select('date', db.raw('SUM(amount) as total'));
      },
      inputSchema: z.object({
        startDate: z.string(),
        endDate: z.string(),
      }),
      custom: {
        // Ownership
        owner: 'Sarah Chen',
        team: 'platform-team',
        contact: 'platform@company.com',

        // Performance
        sla: '150ms',
        p99Target: '300ms',
        cacheable: true,
        ttl: '5m',

        // Business context
        criticality: 'high',
        businessImpact: 'customer-facing dashboard',
        userType: 'external',

        // Cost & optimization
        costEstimate: 'medium',
        estimatedRows: '100k-1M',
        optimizationNotes: 'Uses date-partitioned table',

        // Compliance
        dataClassification: 'internal',
        compliance: ['SOC2'],

        // AI context
        aiDescription: 'Returns daily revenue totals for a date range',
        exampleUse: 'When user asks "show me revenue for last week"',
      },
    },

    // Internal analytics query
    userBehaviorAnalysis: {
      query: async ({ input }) => { /* ... */ },
      inputSchema: z.object({
        userId: z.string(),
        days: z.number(),
      }),
      custom: {
        owner: 'John Smith',
        team: 'data-science',
        sla: '2s',
        costEstimate: 'high',
        estimatedRows: '10M+',
        criticality: 'low',
        businessImpact: 'internal analytics only',
        dataClassification: 'confidential',
        requiresOptimization: true,
        optimizationNotes: 'Consider materialized view',
      },
    },
  },
});
```

## Best practices

### 1. Use consistent schemas

Define a standard metadata schema for your organization:

```typescript
interface StandardMetadata {
  // Required fields
  owner: string;
  team: string;

  // Optional fields
  sla?: string;
  criticality?: 'low' | 'medium' | 'high' | 'critical';
  costEstimate?: 'low' | 'medium' | 'high';
  dataClassification?: 'public' | 'internal' | 'confidential' | 'restricted';
}

// Use consistently across all queries
custom: {
  owner: 'Jane Doe',
  team: 'platform',
  sla: '100ms',
  criticality: 'high',
} satisfies StandardMetadata
```

### 2. Validate metadata in CI

```typescript
// scripts/validate-metadata.ts
import { api } from './api';

const description = api.describe();
const errors: string[] = [];

description.queries.forEach(query => {
  if (!query.custom?.owner) {
    errors.push(`${query.key} missing owner`);
  }
  if (!query.custom?.team) {
    errors.push(`${query.key} missing team`);
  }
  if (query.visibility === 'public' && !query.custom?.sla) {
    errors.push(`${query.key} public endpoint missing SLA`);
  }
});

if (errors.length > 0) {
  console.error('Metadata validation failed:');
  errors.forEach(err => console.error(`  - ${err}`));
  process.exit(1);
}
```

### 3. Generate documentation

Auto-generate API docs from metadata:

```typescript
const docs = api.describe().queries.map(query => `
## ${query.path}

**Owner**: ${query.custom?.owner || 'Unassigned'}
**Team**: ${query.custom?.team || 'Unknown'}
**SLA**: ${query.custom?.sla || 'Not specified'}
**Criticality**: ${query.custom?.criticality || 'Unknown'}

${query.description || 'No description available'}
`).join('\n\n');

fs.writeFileSync('API_DOCS.md', docs);
```

### 4. Track metadata changes

Monitor when critical metadata changes:

```typescript
// In your CI/CD pipeline
const previous = JSON.parse(fs.readFileSync('metadata-snapshot.json'));
const current = api.describe();

current.queries.forEach((query, i) => {
  const prev = previous.queries[i];

  if (query.custom?.owner !== prev.custom?.owner) {
    console.warn(`Owner changed for ${query.key}: ${prev.custom?.owner} -> ${query.custom?.owner}`);
  }

  if (query.custom?.criticality !== prev.custom?.criticality) {
    console.warn(`Criticality changed for ${query.key}: ${prev.custom?.criticality} -> ${query.custom?.criticality}`);
  }
});
```

## FAQ

### Does custom metadata affect performance?

No. Metadata is only accessed via `describe()` and doesn't impact query execution.

### Can I update metadata without redeploying?

No. Metadata is defined at build time. Consider using external config management for dynamic values.

### How do I make metadata mandatory?

Use TypeScript to enforce required fields:

```typescript
custom: {
  owner: 'required!',
  team: 'required!',
} satisfies { owner: string; team: string }
```

### Can AI agents use custom metadata?

Yes! The `describe()` output is perfect for AI agent discovery:

```typescript
// MCP server can expose this
const tools = api.describe().queries.map(q => ({
  name: q.key,
  description: q.custom?.aiDescription || q.summary,
  parameters: q.inputSchema,
}));
```

## Next steps

- Explore [multi-tenant isolation](/docs/ship/multi-tenancy)
- Learn about [observability hooks](/docs/operate/observability)
- See [governance & access control](/docs/operate/governance)

</div>
