---
layout: ../../../layouts/DocsLayout.astro
title: TypeScript SDK generation
description: Generate type-safe client SDKs from your OpenAPI specification
---

<div class="prose">

# TypeScript SDK generation

Generate fully type-safe TypeScript client SDKs from your HypeQuery API's OpenAPI specification. Provide your frontend, mobile apps, and external consumers with auto-generated, type-safe clients that stay in sync with your API.

## Overview

HypeQuery's SDK generator:
- **Generates TypeScript clients** from OpenAPI specs (local files or URLs)
- **Full type inference** - autocomplete and type checking for all endpoints
- **Fetch-based runtime** - works in browsers, Node.js, Deno, Cloudflare Workers
- **Automatic type extraction** - request bodies, query params, and responses
- **Zero configuration** - works out of the box with HypeQuery's OpenAPI generation

## Quick start

### CLI usage

Generate an SDK from your API's OpenAPI spec:

```bash
# From local OpenAPI file
npx hypequery sdk \
  --input ./openapi.json \
  --output ./sdk \
  --clientName MyApiClient

# From remote URL
npx hypequery sdk \
  --input https://api.example.com/openapi.json \
  --output ./generated-sdk \
  --clientName ExternalApiClient
```

This generates:
- `types.ts` - Full TypeScript types from OpenAPI schema
- `client.ts` - Type-safe fetch-based client class
- `index.ts` - Exports for easy importing

### Using the generated SDK

```typescript
import { createClient } from './sdk';

// Create client instance
const client = createClient({
  baseUrl: 'https://api.example.com',
  headers: {
    'authorization': 'Bearer YOUR_TOKEN',
  },
});

// Make type-safe requests
const orders = await client.request({
  path: '/api/orders',
  method: 'GET',
  query: {
    status: 'completed', // ✅ Autocomplete and type-checked!
    limit: 20,
  },
});

// Response is fully typed
orders.forEach(order => {
  console.log(order.id, order.total); // ✅ Type-safe
});

// POST with body
const newOrder = await client.request({
  path: '/api/orders',
  method: 'POST',
  body: {
    items: [{ id: '123', quantity: 2 }],
    customerId: 'cust-456',
  }, // ✅ Type-checked against schema
});
```

## Integration with HypeQuery API

If you're building a HypeQuery API, the SDK generator works seamlessly with the built-in OpenAPI generation:

### Step 1: Define your API

```typescript
// api/index.ts
import { defineServe } from '@hypequery/serve';
import { z } from 'zod';

const api = defineServe({
  openapi: {
    enabled: true,
    path: '/openapi.json',
  },
  queries: {
    getOrders: {
      query: async ({ input }) => {
        return db.table('orders')
          .where('status', input.status)
          .limit(input.limit ?? 20)
          .select('*');
      },
      inputSchema: z.object({
        status: z.enum(['pending', 'completed', 'cancelled']),
        limit: z.number().optional(),
      }),
      outputSchema: z.array(z.object({
        id: z.string(),
        total: z.number(),
        status: z.string(),
        createdAt: z.string(),
      })),
      summary: 'Get orders by status',
    },
  },
});

api.route('/api/orders', api.queries.getOrders);

export { api };
```

### Step 2: Start dev server

```bash
npx hypequery dev
# Server running at http://localhost:4000
# OpenAPI spec: http://localhost:4000/openapi.json
```

### Step 3: Generate SDK

```bash
# Generate SDK from running server
npx hypequery sdk \
  --input http://localhost:4000/openapi.json \
  --output ./client-sdk \
  --clientName OrdersClient
```

### Step 4: Use in your app

```typescript
// frontend/src/api.ts
import { createClient } from '../client-sdk';

export const api = createClient({
  baseUrl: import.meta.env.VITE_API_URL,
  headers: {
    'authorization': `Bearer ${getAuthToken()}`,
  },
});

// components/OrderList.tsx
import { api } from '../api';

export function OrderList() {
  const [orders, setOrders] = useState([]);

  useEffect(() => {
    api.request({
      path: '/api/orders',
      method: 'GET',
      query: { status: 'completed' },
    }).then(setOrders);
  }, []);

  return (
    <ul>
      {orders.map(order => (
        <li key={order.id}>
          Order #{order.id} - ${order.total}
        </li>
      ))}
    </ul>
  );
}
```

## CLI reference

### Command

```bash
npx hypequery sdk [options]
```

### Options

#### `--input, -i <path>` (required)

Path or URL to OpenAPI specification. Supports:
- Local JSON files: `--input ./openapi.json`
- Local YAML files: `--input ./openapi.yaml`
- Remote URLs: `--input https://api.example.com/openapi.json`

```bash
# Local file
npx hypequery sdk --input ./docs/openapi.json --output ./sdk

# Remote URL
npx hypequery sdk --input https://api.acme.com/openapi.json --output ./sdk
```

#### `--output, -o <path>` (required)

Output directory for generated SDK files. Will be created if it doesn't exist.

```bash
npx hypequery sdk \
  --input ./openapi.json \
  --output ./generated/api-client
```

#### `--clientName <name>` (optional)

Name for the generated client class. Defaults to `HypeQueryClient`.

```bash
npx hypequery sdk \
  --input ./openapi.json \
  --output ./sdk \
  --clientName AcmeApiClient
```

Generated client will be:
```typescript
export class AcmeApiClient {
  // ...
}

export const createClient = (config: ClientConfig) => new AcmeApiClient(config);
```

## Generated SDK structure

The SDK generator creates three files:

### `types.ts`

Auto-generated TypeScript types from your OpenAPI schema:

```typescript
export interface paths {
  "/api/orders": {
    get: {
      parameters: {
        query: {
          status: "pending" | "completed" | "cancelled";
          limit?: number;
        };
      };
      responses: {
        200: {
          content: {
            "application/json": Array<{
              id: string;
              total: number;
              status: string;
              createdAt: string;
            }>;
          };
        };
      };
    };
  };
}
```

### `client.ts`

Type-safe fetch-based client with full type inference:

```typescript
export class HypeQueryClient {
  constructor(private readonly config: ClientConfig) {}

  async request<Path extends keyof paths, Method extends keyof paths[Path]>(
    options: RequestOptions<Path, Method>
  ): Promise<ExtractJsonResponse<paths[Path][Method]>> {
    // Fetch implementation with full type safety
  }
}

export const createClient = (config: ClientConfig) => new HypeQueryClient(config);
```

### `index.ts`

Exports for easy importing:

```typescript
export * from "./client";
export * from "./types";
```

## Client configuration

### Basic configuration

```typescript
import { createClient } from './sdk';

const client = createClient({
  baseUrl: 'https://api.example.com',
});
```

### With authentication

```typescript
const client = createClient({
  baseUrl: 'https://api.example.com',
  headers: {
    'authorization': 'Bearer YOUR_TOKEN',
  },
});
```

### With custom fetch

Provide your own fetch implementation (useful for custom interceptors, retries, etc.):

```typescript
const customFetch = async (url: string, options: RequestInit) => {
  // Add logging
  console.log(`${options.method} ${url}`);

  // Add retry logic
  let retries = 3;
  while (retries > 0) {
    try {
      return await fetch(url, options);
    } catch (error) {
      retries--;
      if (retries === 0) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
};

const client = createClient({
  baseUrl: 'https://api.example.com',
  fetch: customFetch,
});
```

## Making requests

### GET requests with query params

```typescript
const users = await client.request({
  path: '/api/users',
  method: 'GET',
  query: {
    page: 1,
    pageSize: 20,
    status: 'active',
  },
});
```

### POST requests with body

```typescript
const newOrder = await client.request({
  path: '/api/orders',
  method: 'POST',
  body: {
    customerId: 'cust-123',
    items: [
      { productId: 'prod-456', quantity: 2 },
      { productId: 'prod-789', quantity: 1 },
    ],
  },
});
```

### PUT/PATCH requests

```typescript
const updatedUser = await client.request({
  path: '/api/users/{id}' as any, // Note: Path params not yet extracted
  method: 'PUT',
  body: {
    name: 'Jane Doe',
    email: 'jane@example.com',
  },
});
```

### DELETE requests

```typescript
await client.request({
  path: '/api/orders/{id}' as any,
  method: 'DELETE',
});
```

### Custom headers per request

```typescript
const data = await client.request({
  path: '/api/sensitive-data',
  method: 'GET',
  headers: {
    'x-api-version': '2.0',
    'x-request-id': generateRequestId(),
  },
});
```

## Type safety

The generated SDK provides full TypeScript type safety:

### Input validation

```typescript
// ✅ Correct usage
await client.request({
  path: '/api/orders',
  method: 'GET',
  query: {
    status: 'completed', // Type-checked against enum
  },
});

// ❌ TypeScript error - invalid status
await client.request({
  path: '/api/orders',
  method: 'GET',
  query: {
    status: 'invalid-status', // TS Error: Type '"invalid-status"' is not assignable
  },
});
```

### Response typing

```typescript
const orders = await client.request({
  path: '/api/orders',
  method: 'GET',
  query: { status: 'completed' },
});

// Response is fully typed based on OpenAPI schema
orders.forEach(order => {
  console.log(order.id);     // ✅ string
  console.log(order.total);  // ✅ number
  console.log(order.items);  // ✅ Array<OrderItem>
});

// ❌ TypeScript error - property doesn't exist
console.log(order.invalidField); // TS Error: Property 'invalidField' does not exist
```

### Method typing

```typescript
// Only valid HTTP methods for this path are allowed
await client.request({
  path: '/api/orders',
  method: 'GET', // ✅ Valid
});

await client.request({
  path: '/api/orders',
  method: 'POST', // ✅ Valid
});

// ❌ TypeScript error if endpoint doesn't support DELETE
await client.request({
  path: '/api/orders',
  method: 'DELETE', // TS Error if not defined in OpenAPI
});
```

## Error handling

The client throws descriptive errors for failed requests:

```typescript
try {
  const orders = await client.request({
    path: '/api/orders',
    method: 'GET',
    query: { status: 'completed' },
  });
} catch (error) {
  // Error includes status code and response body
  console.error(error.message);
  // "Request failed with status 401: {"error": {"type": "UNAUTHORIZED", ...}}"
}
```

### Typed error handling

```typescript
interface ApiError {
  error: {
    type: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

try {
  await client.request({ ... });
} catch (error) {
  if (error instanceof Error) {
    try {
      const apiError: ApiError = JSON.parse(
        error.message.split(': ')[1]
      );

      if (apiError.error.type === 'VALIDATION_ERROR') {
        console.log('Validation failed:', apiError.error.details);
      }
    } catch {
      console.error('Request failed:', error.message);
    }
  }
}
```

## Workflow integration

### CI/CD pipeline

Generate SDK automatically in your CI pipeline:

```yaml
# .github/workflows/generate-sdk.yml
name: Generate SDK

on:
  push:
    branches: [main]

jobs:
  generate-sdk:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Start API server
        run: |
          npm run build
          npm run start &
          sleep 5

      - name: Generate SDK
        run: |
          npx hypequery sdk \
            --input http://localhost:4000/openapi.json \
            --output ./packages/sdk

      - name: Commit SDK changes
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add packages/sdk
          git commit -m "chore: update generated SDK" || echo "No changes"
          git push
```

### Package as NPM module

Publish your generated SDK as an NPM package:

```json
{
  "name": "@acme/api-client",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc",
    "generate": "hypequery sdk --input https://api.acme.com/openapi.json --output ./src"
  },
  "dependencies": {},
  "devDependencies": {
    "@hypequery/serve": "latest",
    "typescript": "^5.0.0"
  }
}
```

### Development workflow

1. **Make API changes** in your HypeQuery API
2. **Restart dev server** to update OpenAPI spec
3. **Regenerate SDK** with updated types
4. **Type errors in frontend** guide you to update consuming code

```bash
# Terminal 1: Run API dev server
npx hypequery dev

# Terminal 2: Watch and regenerate SDK on changes
npx nodemon --watch api --ext ts --exec \
  "npx hypequery sdk -i http://localhost:4000/openapi.json -o ./sdk"
```

## Real-world examples

### React app with generated SDK

```typescript
// lib/api.ts
import { createClient } from '../generated-sdk';

export const api = createClient({
  baseUrl: import.meta.env.VITE_API_URL,
  headers: {
    'content-type': 'application/json',
  },
});

// Add auth token to requests
export const authenticatedApi = (token: string) =>
  createClient({
    baseUrl: import.meta.env.VITE_API_URL,
    headers: {
      'authorization': `Bearer ${token}`,
      'content-type': 'application/json',
    },
  });

// hooks/useOrders.ts
import { useQuery } from '@tanstack/react-query';
import { authenticatedApi } from '../lib/api';

export function useOrders(status: 'pending' | 'completed' | 'cancelled') {
  const token = useAuthToken();

  return useQuery({
    queryKey: ['orders', status],
    queryFn: async () => {
      const client = authenticatedApi(token);
      return client.request({
        path: '/api/orders',
        method: 'GET',
        query: { status },
      });
    },
  });
}

// components/OrderList.tsx
export function OrderList() {
  const { data: orders, isLoading } = useOrders('completed');

  if (isLoading) return <Spinner />;

  return (
    <ul>
      {orders?.map(order => (
        <li key={order.id}>
          Order #{order.id} - ${order.total}
        </li>
      ))}
    </ul>
  );
}
```

### Node.js backend consuming API

```typescript
// services/analytics.ts
import { createClient } from '../generated-sdk';

const analyticsApi = createClient({
  baseUrl: process.env.ANALYTICS_API_URL!,
  headers: {
    'x-api-key': process.env.ANALYTICS_API_KEY!,
  },
});

export async function trackEvent(event: {
  type: string;
  userId: string;
  metadata: Record<string, unknown>;
}) {
  return analyticsApi.request({
    path: '/api/events',
    method: 'POST',
    body: event,
  });
}

export async function getMetrics(dateRange: { start: string; end: string }) {
  return analyticsApi.request({
    path: '/api/metrics',
    method: 'GET',
    query: {
      startDate: dateRange.start,
      endDate: dateRange.end,
    },
  });
}
```

## Best practices

### 1. Version your SDK with your API

Keep SDK generation tied to API versions:

```bash
# Generate SDK for specific API version
npx hypequery sdk \
  --input https://api.example.com/v2/openapi.json \
  --output ./sdk/v2 \
  --clientName ApiClientV2
```

### 2. Commit generated code

Commit generated SDK to source control for:
- Easier code review of API changes
- No build-time dependencies on API server
- Faster CI/CD (no regeneration needed)

```gitignore
# Don't ignore generated SDK
# sdk/
```

### 3. Add SDK types to TypeScript paths

Make imports cleaner:

```json
{
  "compilerOptions": {
    "paths": {
      "@api/*": ["./sdk/*"]
    }
  }
}
```

```typescript
// Instead of
import { createClient } from '../../../sdk';

// Use
import { createClient } from '@api';
```

### 4. Create SDK wrapper utilities

Add convenience methods:

```typescript
// lib/api-wrapper.ts
import { createClient } from '../sdk';

export function createApiClient(options?: { token?: string }) {
  const client = createClient({
    baseUrl: process.env.API_URL!,
    headers: {
      ...(options?.token && { authorization: `Bearer ${options.token}` }),
    },
  });

  return {
    client,
    // Convenience methods
    orders: {
      list: (status: string) => client.request({
        path: '/api/orders',
        method: 'GET',
        query: { status },
      }),
      create: (order: any) => client.request({
        path: '/api/orders',
        method: 'POST',
        body: order,
      }),
    },
  };
}
```

### 5. Keep OpenAPI spec accessible

Ensure your OpenAPI spec is available during development:

```typescript
// api/index.ts
const api = defineServe({
  openapi: {
    enabled: true,
    path: '/openapi.json', // Always enabled
  },
  // ...
});
```

## Limitations

Current limitations to be aware of:

1. **Path parameters** - Not yet automatically extracted. Use type assertions:
   ```typescript
   client.request({
     path: '/api/users/123' as '/api/users/{id}',
     method: 'GET',
   });
   ```

2. **Fetch-only runtime** - Only generates fetch-based clients. Axios support planned but not implemented.

3. **OpenAPI 3.x only** - Requires OpenAPI 3.0+ specification. Swagger 2.0 not supported.

## Next steps

- Learn about [HTTP + OpenAPI](/docs/ship/http-openapi) generation
- Explore [API documentation UI](/docs/ship/serve-dev#documentation-ui)
- See [deployment patterns](/docs/ship/embedded-runtime) for hosting your API

</div>
